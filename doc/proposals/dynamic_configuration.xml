<?xml version="1.0"?>
<?xml-stylesheet href="../scheduler.xsl" type="text/xsl"?>

<!--$Id$-->

<description
    title               = "Dynamische Konfiguration: Scheduler-Objekte in eigenen XML-Dateien"
    base_dir            = "../"
    parent_page         = "index.xml"
    author              = "$Author$"
    date                = "$Date$"
    document_state      = "proposal"
>
    <p>
        Siehe auch
    </p>
    <ul>
        <li>
            <scheduler_a href="dynamic_configuration_commands.xml"/>
        </li>
        <li>
            <scheduler_a href="directories.xml"/>
        </li>
        <li>
            <scheduler_a href="dynamic_configuration_with_supervisor.xml"/>
        </li>
    </ul>
    <p>
        Jobs, Jobketten, Daueraufträge, Prozessklassen und Sperren (das alles hier Objekte genannt)
        müssen nicht mehr in einer gemeinsamen Konfigurationsdatei, 
        sondern können in einzelnen Dateien gehalten werden, die der Scheduler automatisch nach Änderung übernimmt
    </p>
    <p>
        Der Scheduler überwacht das Verzeichnis und übernimmt hinzugefügte und geänderte Dateien.
        Eine gelöschte Datei lässt den Scheduler das Objekt im Scheduler löschen.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <scheduler_table_of_content/>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Dateien für Jobs, Jobketten, Daueraufträge, Prozessklassen und Sperren</h2>

    <p>
        Hinzugefügte, geänderte und gelöschte Dateien lösen entsprechende Kommandos aus.
    </p>
    <p style="margin-bottom: 1em;">
        <i>
            Die Kommandos zum Löschen werden nicht also solche nicht realisiert.
            Die Kommandos stehen symbolisch für die im Scheduler zu realisierenden internen Funktionen.
        </i>
    </p>
    <table cellspacing="0" cellpadding="0">
        <tr>
            <th style="padding-right: 2ex">
                Dateiname
            </th>
            <th style="padding-right: 2ex">
                Hinzufügen, Ändern
                <br/>
                (alle mit <code>replace="yes")</code>
            </th>
            <th>
                Löschen
            </th>
            
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                <i>name</i><code>.job.xml</code>
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="job"/>
            </td>
            <td>
                <scheduler_element name="job.remove"/>
            </td>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                <i>name</i><code>.job_chain.xml</code>
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="job_chain"/>
            </td>
            <td>
                <scheduler_element name="job_chain.remove"/>
            </td>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                <i>jobchainname</i><code>#</code><i>orderid</i><code>.order.xml</code>
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="order"/>
            </td>
            <td>
                <scheduler_element name="order.remove"/>
            </td>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                <i>name</i><code>.process_class.xml</code>
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="process_class"/>
            </td>
            <td>
                <scheduler_element name="process_class.remove"/>
            </td>
        </tr>
        <tr>
            <td>
                <i>name</i><code>.lock.xml</code>
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="lock"/>
            </td>
            <td>
                <scheduler_element name="lock.remove"/>
            </td>
        </tr>
    </table>

    <p>
        Das Attribut <code>name=</code> 
        (oder <code>job_chain=</code> und <code>id=</code> bei Aufträgen)
        kann angegeben werden und muss dann dem Dateinamen entsprechen.
    </p>
    <p>
        Jobkettennamen dürfen kein <code>#</code> mehr enthalten.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Daueraufträge</h2>
    <p>
        Daueraufträge werden anders behandelt als die anderen Objekte.
        Zum einen haben sie einen anderen Namen (<code>job_chain=</code> und <code>id=</code> statt <code>name=</code>),
        zum anderen werden Dateiänderungen nicht jederzeit beachtet.
        Eine gelöschte oder geänderte Auftragsdatei wird nur beachtet,
        wenn die Jobkette aktiv (<code>state=running</code>) ist und
    </p>
    <ul>
        <li>
            der Auftrag nicht bekannt,
        </li>
        <li>
            der Auftrag noch nicht gestartet worden oder
        </li>
        <li>
            der Auftrag wegen <scheduler_element name="run_time"/> wiederholt, aber noch nicht gestartet worden ist.
        </li>
    </ul>
    <p style="color: red">
        Was machen wir mit Aufträgen, die sich nicht wiederholen?
        Der Scheduler würde sofort die Auftragsdatei lesen und den Auftrag ohne Pause erneut starten.
        Wir müssen den Auftrag auf eine Art schwarzer Liste setzen
        (die gibt es jetzt nur für Dateiaufträge und könnte vielleicht erweitert werden).
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Verzeichnisüberwachung</h2>

    <p>
        Die Algorithmen der Verzeichnisüberwachung (getrennt für Windows und Unix)
        werden nicht nur Änderungen der Dateinamensliste,
        sondern auch die Zeitstempel der Dateien überwachen,
        um Änderungen an bekannten Dateien festzustellen.
    </p>
    <p>
        Unter Windows wird dazu eine Systemfunktion benutzt, die über Änderungen benachrichtigt.
        Dazu macht Microsoft einen (möglicherweise praktisch bedeutungslosen) Hinweis:
    </p>
    <p class="indent">
        "<i>The operating system detects a change to the last write-time only 
        when the file is written to the disk. 
        For operating systems that use extensive caching, 
        detection occurs only when the cache is sufficiently flushed.</i>"
        (<a href="http://msdn2.microsoft.com/en-us/library/aa364417.aspx">http://msdn2.microsoft.com/en-us/library/aa364417.aspx</a>).
    </p>

    <p>
        Das Verzeichnis wird eingestellt mit dem neuen Attribut
        <scheduler_element name="config" attribute="directory"/>.
        Voreingestellt ist das Unterverzeichnis <code>configurations</code> im Verzeichnis der Konfigurationsdatei.
        Das Attribut ist in mit <scheduler_element name="base"/> eingezogenen Basiskonfigurationen wirkungslos.
    </p>
    <p>
        Das Verzeichnis sollte nur hier spezifizierte Dateien enthalten.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
    
    <h2>Spiegelung des Verzeichnisses im Scheduler</h2>

    <p>
        Der Scheduler legt für jede Datei mit bekannter Dateinamensendung (<code>.job</code> usw.)
        ein entsprechendes Objekt im Scheduler an und verbindet es mit der Datei.
        Der Scheduler überwacht das Verzeichnis und die Zeitstempel der Dateien und geht bei Änderungen wie folgt vor.
    </p>
    
    <ul class="big">
        <li>
            Ein hinzugefügter Dateiname führt zu Anlage eines neuen, noch leeren Objekts im Scheduler,
            das mit der Datei verbunden wird.
            Das Objekt ist mit <scheduler_element name="show_state"/> sichtbar.
            Z.B. wird eine Datei <code>xxx.job.xml</code> im Scheduler gespiegelt als ein Job
            <scheduler_element name="job" attribute="name" value="xxx"/>,
            auch wenn die Datei nicht lesbar ist.
        </li>
        <li>
            Eine gelöschte Datei führt zum Löschen des Objekts.
            Das Löschen läuft in der Regel asynchron, weil z.B. bei einem Job das Ende der Tasks abgewartet werden muss.
        </li>
        <li>
            Wenn während des Löschens die Datei wieder angelegt wird,
            geht der Scheduler wie beim Ändern der Datei vor.
        </li>
        <li>
            Nach einer Änderung einer Datei (der Zeitstempel hat sich geändert) liest der Scheduler die Datei.
            Kann die Datei geladen werden, 
            dann tauscht er Prozessklassen und Sperren direkt,
            während er Jobs, Jobklassen und Daueraufträge verzögert tauscht,
            weil noch die laufende Operation des zu ersetzenden Objekts abgewartet werden muss (Details unten).
        </li>
        <li>
            Ein Fehler beim Lesen einer Datei beeinflusst nicht ein bereits vorhandenes Objekt.
            Der Scheduler vermerkt den Fehler im Objekt und verschickt eine eMail.
            <scheduler_element name="show_state"/> zeigt den Fehler.
        </li>
    </ul>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <p color="red">
        Was passiert, wenn eine Objekt mit einem Kommando gelöscht wird?
        Das sollte nicht möglich sein. 
        Dateibasierte Objekte sollten nur durchs Löschen der Datei entfernt werden können.
    </p>
    
    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

</description>
