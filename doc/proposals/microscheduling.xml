<?xml version="1.0"?>
<?xml-stylesheet href="../scheduler.xsl" type="text/xsl"?>

<!--$Id$-->

<description
    title               = "Erneuertes Mikro-Scheduling"
    base_dir            = "../"
    parent_page         = "index.xml"
    author              = "$Author$"
    date                = "$Date$"
    document_state      = "work_in_progress"
>
    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <scheduler_table_of_content/>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Derzeitiger Algorithmus</h2>

    <p>
        Der Scheduler reagiert auf Ereignisse. 
        Die "Große Schleife" des Schedulers wartet auf das nächste Ereignis,
        um es zu behandeln.
        Dazu ruft er solange Objekte 
        (v.a. Jobs und Tasks) auf, bis keins mehr etwas zu tun hat.
        Schließlich wartet der Scheduler auf das nächste Ereignis.
        Dieser Algorithmus stammt noch vom allerersten Scheduler, 
        der nur wenige Ereignisse und wenige Jobs kannte.
    </p>
    <p>
        Der Algorithmus hat zwei Nachteile:
    </p>
    <ul>
        <li>
            Es gibt keine Zuordnung zwischen Ereignis und Objekt.
            Nach einem Ereignis ruft der Scheduler alle Objekte auf,
            die dann selbst prüfen müssen, ob sie etwas zu tun haben.
            Wenn ein Objekt fehlerhaft ein vom ihm veranlasstes Ereignis nicht erledigt,
            kommt es zu einer Schleife,
            die der Scheduler mit <scheduler_message code="SCHEDULER-261"/> bremst.
        </li>
        <li>
            Es ist überflüssig, nach jedem kleinen Ereignis alle Jobs und Tasks zu durchlaufen.
            Der Scheduler wird durch einen neuen Algorithmus sparsamer mit CPU-Zeit umgehen.
        </li>
    </ul>

    
    <h2>Ereignisse</h2>

    <p class="zwischentitel">Zeit-Ereignisse</p>
    <ul>
        <li>
            <scheduler_element name="run_time"/>
            für Job und Auftrag: repeat, absolute_repeat, single_start
        </li>
        <li>
            Task mit Startzeit: <scheduler_element name="start_job" attribute="at"/>
        </li>
        <li>
            Auftrag mit Startzeit: <scheduler_method class="Order" property="at"/>.
        </li>
        <li>
            Sommerzeitumschaltung (UTC)
        </li>
        <li>
            Frist für Verbindung vom Task-Prozess (eine Minute)
        </li>
        <li>
            Wiederholung des Verbindungsversuch zum Supervisor
        </li>
        <li>
            <scheduler_element name="start_when_directory_changed"/>: Periodisches Prüfen
        </li>
        <li>
            Periodische Überwachung der Konfigurationsverzeichnisse
        </li>
        <li>
            ...
        </li>
        <li>
        </li>
        <li>
        </li>
        <li>
        </li>
    </ul>


    <p class="zwischentitel">Betriebssystem-Ereignisse</p>
    <ul>
        <li>
            Prozessende (API- und Nicht-API-Tasks)
        </li>
        <li>
            <scheduler_element name="start_when_directory_changed"/>: Periodisches Prüfen
        </li>
        <li>
            Überwachung der Konfigurationsverzeichnisse
        </li>
        <li>
            Sockets für XML und HTTP (Verbindungsauf- und -abbau, Datenempfang, Daten versendbar)
        </li>
        <li>
            Sockets zur Kommunikation mit einer Task
        </li>
        <li>
            Waitable Timer
        </li>
        <li>
            Signalisierung zwischen Threads:
            <ul>
                <li>
                    Cluster: Watchdog-Thread, der den Scheduler überwacht <i>(welches Signal?)</i>
                </li>
                <li>
                    <i>welche?</i>
                </li>
            </ul>
        </li>
    </ul>

    <p class="zwischentitel">Außerdem</p>
    <ul>
        <li>
            _wait_handles
        </li>
        <li>
            Scheduler-Ereignis (Spooler::_event)
        </li>
        <li>
            TCP/HTTP-Empfang und -Versand
        </li>
    </ul>


    <p class="zwischentitel">Innere Ereignisse</p>
    <ul>
        <li>
            Job soll prüfen, ob eine Task zu starten ist
            <ul>
                <li>
                    Nach Sommerzeitumschaltung die <scheduler_element name="run_time"/> neu berechnen
                </li>
                <li>
                    Neue Task in Task-Warteschlange
                </li>
                <li>
                    <scheduler_element name="delay_after_error"/>
                </li>
                <li>
                    Neuer Auftrag im Jobkettenknoten
                </li>
            </ul>
        </li>
        <li>Task
            <ul>
                <li>
                    Verbindung zum Task-Prozess unterbrochen
                </li>
                <li>
                    Task-Prozess beendet
                </li>
                <li>
                    Verbindungsaufbau vom Task-Prozess nach dessen Start
                </li>
                <li>
                    <scheduler_method class="Task" property="delay_spooler_process"/>
                </li>
                <li>
                    Methode des Task-Prozesses beendet (z.B. <scheduler_method class="Job_impl" method="spooler_process"/>).
                    Dazu gehören auch interne Methoden, 
                    z.B. Übergabe und Freigabe der Objekte (<scheduler_method class="Job_impl" property="spooler_task"/> usw.).
                </li>
                <li>
                    Verzögertes Löschen der stdout- und stderr-Dateien.
                </li>
            </ul>
        </li>
        <li>
            <scheduler_element name="modify_spooler"/>,
            <scheduler_element name="terminate"/> usw.: 
            Anweisungen an den Scheduler, die nicht sofort ausgeführt werden.
        </li>
        <li>
            Scheduler-Ereignis (Spooler::_event)
        </li>
    </ul>


    <h2>Mikroscheduling</h2>
    <ul>
        <li>
            Signal direkt mit ausführenden Objekt verbinden.
            Nur das signalierte Objekt soll aufgerufen werden.
        </li>
        <li>
            Feststellen, welche Signale oder Ereignisse es gibt,
            wer sie auslöst und welche Objekte benachrichtigt werden sollen.
            <ul>
                <li>
                    Prozessende -> Task oder Subprozess
                </li>
                <li>
                    Wecker -> Task, Auftrag usw.
                </li>
                <li>
                    Verzeichnisänderung -> Job, Konfigurationsdatei, Dateiauftrag
                </li>
                <li>
                    TCP -> Kommando lesen oder Antwort fortsetzen
                </li>
                <li>
                    ...
                </li>
            </ul>
        </li>
        <li>
            Warteschlange der Signale(?) und nächsten Weckereignisse
        </li>
        <li>
            Per XML Liste der von Objekten erwarteteten Ereignisse liefern.
        </li>
    </ul>


    Ziele:
    <ul>
        <li>
            Klare, dokumentierte Zusammenhänge zwischen Ereignissen und behandelnden Objekten.
        </li>
        <li>
            CPU-Verbrauch bei vielen Jobs und Tasks sollte deutlich kleiner werden, 
            weil bei einem Ereignis nicht mehr alle Objekte aufgerufen werden, sondern gleich das richtige.
        </li>
        <li>
            Die Bremse <scheduler_message code="SCHEDULER-261"/> wird endlich überflüssig.
        </li>
        <li>
            Vielleicht lässt sich manche Ereignisbehandlung in einem Thread parallelisieren.
        </li>
    </ul>




    <h2>Problem</h2>

    <p>
        Der Scheduler ruft bei jedem Ereignis fast alle Objekte auf.
    </p>

    <p>
        Feststellen, welche Signale oder Ereignisse es gibt,
        wer sie auslöst und welche Objekte benachrichtigt werden sollen.
    </p>

    BESSER
    <ul>
        <li>
            Jedes Ereignis ist direkt einem Objekt zugeordnet.
        </li>
        <li>
            Das Objekt muss auf das Ereignis reagieren, sonst ist es ein Fehler.
        </li>
        <li>
            Beim Eintritt eines Ereignisses ruft der Scheduler direkt das damit verbundene Objekt auf
        </li>
        <li>
            --> Verbindung zwischen Ereignis und Objekt
        </li>
        <li>
            Async_operation verwenden
        </li>
        <li>
            Job und Task zu Async_operation machen???
        </li>
        <li>
            Windows-Events mit Objekt (also Async_operation) verbinden
        </li>
        <li>
            Socket-Events auf Callbacks umstellen (Begrenzung von WaitForMultipleObjects() umgehen) und mit Async_operation verbinden
        </li>
        <li>
            select() mit signal() verbinden --> pselect() (man select_tut) und mit Async_operation verbinden
        </li>
        <li>
            Unix-Scheduler wartet auf signal (nicht mehr mit select() warten)
        </li>
        <li>
            Mehrere Threads? Z.B. HTTP-Server.
        </li>
    </ul>


    <h2>Ablauf der Großen Scheduler-Schleife</h2>

    <ul>
        <li>
            Scheduler aktivieren (wenn backup-Scheduler wartet)
            <scheduler_element name="modify_spooler"/>
                , <scheduler_element name="terminate"/>
            usw. ausführen
        </li>
        <li>
            Prozesse fortsetzen (com_remote.cxx)
        </li>
        <li>
            Task_subsystem::process()
        </li>
        <li>
            Job_subsystem::remove_temporary_jobs()
        </li>
        <li>
            Nicht-auftragsgesteuerte Jobs: do_something()
        </li>
        <li>
            Auftragsgesteuerte Jobs: do_something(), nach Priorität in der Jobkette (klären!)
        </li>
        <li>
            Auftragsgesteuerte Tasks: do_something(), nach Priorität in der Jobkette (klären!)
        </li>
        <li>
            Nicht-auftragsgesteuerte Tasks: do_something()
        </li>
        <li>
            Außerdem remove_ended_tasks()
        </li>
        <li>
            Connection_manager::async_continue()
        </li>
        <li>
            Welche Objekte sind das?
        </li>
        <li>
            Cluster::check()?
        </li>
        <li>
            Order_subsystem::check_exception()
        </li>
        <li>
            Database_order_detector::async_check_exception()
        </li>
        <li>
            Alle Tasks beendet? Scheduler kann beendet werden.
        </li>
        <li>
            Warten ...
        </li>
        <li>
            Ctrl-C

        </li>
    </ul>

    <h2>JOBS UND TASKS NICHT BEI JEDEM EREIGNIS DURCHLAUFEN</h2>

    <p>
        Wenn ein continue/do_somethine() true liefert ("something_done"), wiederholt der Scheduler die Schleife
        Das muss ersetzt werden durch direkte Signalisierung: Z.B. wenn ein Auftrag weitergereicht wird, muss der nächste Job benachrichtigt werden.
        Jobs an hinterer Stelle in einer Jobkette sollten vorrangig gestartet werden. Wie lösen wir das? Wir brauchen einen zentralen Verteiler, am besten im Jobkettensubsystem (Order_subsystem). Diese Priorisierung ist wirksam, wenn die Prozessklasse nicht genügend Tasks starten lässt. Gibt es noch weitere Bedingungen? Ist das nicht ein Problem der Prozessklassen? Wenn mehrere Jobs derselben Prozessklasse wegen Aufträgen starten sollen, aber nicht genügend Prozesse bereitgestellt sind, soll die Prozessklasse entscheiden, welcher Job startet.
    </p>


    <h2>Async_operation</h2>

    <p>
        Alles auf Async_operation umstellen
        Async_operation hat zwei Funktionalitäten (com_remote.cxx und andere).
        Die sollten geklärt, in zwei Klassen aufgespalten und vereinfacht werden.
    </p>
    <p>
        Mit Windows-Ereignissen verbinden. 
        Eintreffen des Ereignisses soll direkt das Objekt (async_continue oder neue Methode async_on_event) aufrufen.
        Entsprechende Lösung für Unix finden. Signale und select() einbeziehen.
    </p>

</description>                                     
