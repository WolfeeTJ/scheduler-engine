<?xml version="1.0"?>
<?xml-stylesheet href="../scheduler.xsl" type="text/xsl"?>

<!--$Id$-->

<description
    title               = "Dateibasierte Konfiguration: Scheduler-Objekte in eigenen XML-Dateien"
    base_dir            = "../"
    parent_page         = "index.xml"
    author              = "$Author$"
    date                = "$Date$"
    document_state      = "proposal"
>
    <p>
        Jobs, Jobketten, Daueraufträge, Prozessklassen und Sperren (das alles hier Objekte genannt)
        müssen nicht mehr in einer gemeinsamen Konfigurationsdatei, 
        sondern können in einzelnen Dateien gehalten werden, die der Scheduler automatisch nach Änderung übernimmt
    </p>
    <p>
        Der Scheduler überwacht das Verzeichnis und übernimmt hinzugefügte und geänderte Dateien.
        Eine gelöschte Datei lässt den Scheduler das Objekt im Scheduler löschen.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <scheduler_table_of_content/>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Objekte: Jobs, Jobketten, Daueraufträge, Prozessklassen und Sperren</h2>

    <p style="margin-bottom: 1em;">
        Objekte sind in diesem Text:
    </p>
    <table cellspacing="0" cellpadding="0">
        <tr>
            <th style="padding-right: 2ex">
                Objekt
            </th>
            <th style="padding-right: 2ex">
                XML-Wurzelelement
            </th>
            <th style="padding-right: 2ex">
                Dateiname
            </th>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                Jobs
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="job"/>
            </td>
            <td>
                <i>name</i><code>.job.xml</code>
            </td>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                Jobketten
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="job_chain"/>
            </td>
            <td>
                <i>name</i><code>.job_chain.xml</code>
            </td>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                Daueraufträge
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="order"/>
            </td>
            <td>
                <i>jobchainname</i><code>#</code><i>orderid</i><code>.order.xml</code>
            </td>
        </tr>
        <tr>
            <td style="padding-right: 2ex">
                Prozessklassen
            </td>
            <td style="padding-right: 2ex">
                <scheduler_element name="process_class"/>
            </td>
            <td>
                <i>name</i><code>.process_class.xml</code>
            </td>
        </tr>
        <tr>
            <td>
                Sperren
            </td>
            <td>
                <scheduler_element name="lock"/>
            </td>
            <td>
                <i>name</i><code>.lock.xml</code>
            </td>
        </tr>
    </table>

    <p>
        Das Attribut <code>name=</code> 
        (oder <code>job_chain=</code> und <code>id=</code> bei Aufträgen)
        kann angegeben werden und muss dann dem Dateinamen entsprechen.
    </p>
    <p>
        Jobkettennamen dürfen kein <code>#</code> mehr enthalten.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Verzeichnisüberwachung</h2>

    <p>
        Die Algorithmen der Verzeichnisüberwachung (getrennt für Windows und Unix)
        werden nicht nur Änderungen der Dateinamensliste,
        sondern auch die Zeitstempel der Dateien überwachen,
        um Änderungen an bekannten Dateien festzustellen.
    </p>
    <p>
        Unter Windows wird dazu eine Systemfunktion benutzt, die über Änderungen benachrichtigt.
        Dazu macht Microsoft einen (möglicherweise praktisch bedeutungslose) Hinweis:
    </p>
    <p class="indent">
        "<i>The operating system detects a change to the last write-time only 
        when the file is written to the disk. 
        For operating systems that use extensive caching, 
        detection occurs only when the cache is sufficiently flushed.</i>"
        (<a href="http://msdn2.microsoft.com/en-us/library/aa364417.aspx">http://msdn2.microsoft.com/en-us/library/aa364417.aspx</a>).
    </p>

    <p>
        Das Verzeichnis wird eingestellt mit dem neuen Attribut
        <scheduler_element name="config" attribute="directory"/>.
        Voreingestellt ist das Unterverzeichnis <code>configurations</code> im Verzeichnis der Konfigurationsdatei.
        Das Attribut ist in mit <scheduler_element name="base"/> eingezogenen Basiskonfigurationen wirkungslos.
    </p>
    <p>
        Das Verzeichnis sollte nur hier spezifizierte Dateien enthalten.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    
    <h2>Spiegelung des Verzeichnisses im Scheduler</h2>

    <p>
        Der Scheduler legt für jede Datei mit bekannter Dateinamensendung (<code>.job</code> usw.)
        ein entsprechendes Objekt im Scheduler an und verbindet es mit der Datei.
        Der Scheduler überwacht das Verzeichnis und die Zeitstempel der Dateien und geht bei Änderungen wie folgt vor.
    </p>
    
    <ul class="big">
        <li>
            Ein hinzugefügter Dateiname führt zu Anlage eines neuen, noch leeren Objekts im Scheduler,
            das mit der Datei verbunden wird.
            Das Objekt ist mit <scheduler_element name="show_state"/> sichtbar.
            Z.B. wird eine Datei <code>xxx.job.xml</code> im Scheduler gespiegelt als ein Job
            <scheduler_element name="job" attribute="name" value="xxx"/>,
            auch wenn die Datei nicht lesbar ist.
        </li>
        <li>
            Eine gelöschte Datei führt zum Löschen des Objekts.
            Das Löschen läuft in der Regel asynchron, weil z.B. bei einem Job das Ende der Tasks abgewartet werden muss.
        </li>
        <li>
            Wenn während des Löschens die Datei wieder angelegt wird,
            geht der Scheduler wie beim Ändern der Datei vor.
        </li>
        <li>
            Nach einer Änderung einer Datei (der Zeitstempel hat sich geändert) liest der Scheduler die Datei.
            Kann die Datei geladen werden, 
            dann tauscht er Prozessklassen und Sperren direkt,
            während er Jobs, Jobklassen und Daueraufträge verzögert tauscht,
            weil noch die laufende Operation des zu ersetzenden Objekts abgewartet werden muss (Details unten).
        </li>
        <li>
            Ein Fehler beim Lesen einer Datei beinflusst nicht ein bereits vorhandenes Objekt.
            Der Scheduler vermerkt den Fehler im Objekt und verschickt eine eMail.
            <scheduler_element name="show_state"/> zeigt den Fehler.
        </li>
    </ul>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Kommandos</h2>

    <p>
        Ändern und Löschen einer Datei sollten wirken wie ein Kommando.
        Die Kommandos sollten erweitert und vereinheitlicht werden.
    </p>
    
    <div class="max_width" style="margin-top: 1em">
        <table cellspacing="0" cellpadding="0" >
            <tr>
                <th style="padding-right: 2ex">
                    Datei
                </th>
                <th style="padding-right: 2ex">
                    Kommando zum Ändern
                </th>
                <th>
                    Kommando zum Löschen
                </th>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.job.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="job" attribute="replace" value="yes"/>
                    <div style="color: red">
                        neu: <scheduler_element name="job"/>?
                    </div>
                </td>
                <td>
                    <scheduler_element name="job.remove"/> (neu)
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.job_chain.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="job_chain"/>
                </td>
                <td>
                    <scheduler_element name="job_chain.remove"/>.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.order.xml</code>
                    <div class="small">
                        (nur erkannt, wenn Auftrag nicht gerade ausgeführt wird)
                    </div>
                </td>
                <td style="padding-top: 0.5em;">
                    <scheduler_element name="order"/>
                    <br/>
                    (ähnlich <scheduler_element name="add_order"/>)
                </td>
                <td>
                    <scheduler_element name="remove_order"/>
                    <div style="color: red">
                        neu: <scheduler_element name="order.remove"/>
                    </div>
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.process_class.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="process_class"/>
                </td>
                <td>
                    <scheduler_element name="process_class.remove"/>
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.lock.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="lock"/>
                    <div style="color: red">
                        Funtioniert nicht, wenn <code>max_non_exclusive</code> zu klein ist.
                    </div>
                </td>
                <td>
                    <scheduler_element name="lock.remove"/>
                    <div style="color: red">
                        Funktioniert nicht, wenn Sperre in Gebrauch.
                    </div>
                </td>
            </tr>
        </table>
    </div>
    
    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Ändern und Löschen der Objekte</h2>


    <h3>Jobs</h3>

    <p>
        Der Scheduler kann auch auftragsgesteuerte Jobs ersetzen und löschen.
        Um einen Job, auf den ein Jobkettenknoten verweist, löschen zu können, müssen die Aufträge erhalten bleiben.
        Der Scheduler wird also die Aufträge im Jobkettenknoten speichern.
        Die Auftragswarteschlange des Jobs enthält nur noch Verweise.
        Aufträge, die von einem Job verarbeitet werden sollen, der gelöscht ist (oder wird),
        bleiben am Jobkettenknoten stehen.
        Erst wenn ein neuer Job gleichen Namens wieder hinzugefügt wird
        (muss auftragsgesteuert sein),
        werden die Auftrage fortgesetzt.
    </p>        
    
    <ul class="big">
        <li>
            Auftragsgesteuerte Jobs können wie normale Jobs gelöscht werden.
        </li>
        <li>
            Dazu wird der Job gestoppt: Tasks werden beendet, Aufträge nicht ausgeführt.
        </li>
        <li>
            Die Aufträge bleiben erhalten, sie stauen sich mit den neu eintreffenden vor dem gelöschten Job. 
            D.h. Jobkettenknoten mit gelöschtem Job sind möglich.
        </li>
        <li>
            Wenn ein Job von mehreren Jobketten benutzt wird,
            geht durch diese Änderung die ursprüngliche Reihenfolge verloren.
            Der Job wird erst Aufträge der einen, dann der nächsten Jobkette ausführen.
            Das gilt bereits heute für verteilte Aufträge, die Aufträge direkt aus der Datenbank gelesen werden,
            wo sie nicht unter dem Jobnamen, sondern unter Jobkette und Zustand abgelegt sind (also praktisch im Jobkettenknoten).
            Die Reihenfolge nach Starzeit und Priorität bleibt erhalten.
        </li>
        <li>
            Solange ein Jobkettenknoten auf einen fehlenden Job verweist, 
            hält der Scheduler einen leeren Job vor, der im Zustand <i>vermisst</i> ist.
            Einziger Eintrag ist, dass es sich um einen auftragsgesteuerten Job handelt.
        </li>
        <li>
            Wenn der vermisster auftragsgesteuerter Job geladen wird, 
            muss er weiterhin ein auftragsgesteuerter Job sein.
        </li>
        <li>
            Der Job kann erneuert werden, während er zum Löschen markiert ist (weil noch Tasks laufen). 
            Die Erneuerung wird dann bis zum wirklichen Löschen verzögert.
        </li>
        <li>
            Ein wiedereingefügter Job baut seine Warteschlange der Aufträge wieder auf.
        </li>
        <li>
            Das neue Kommando <code>&lt;job.remove job=""></code> wirkt wie <scheduler_element name="modify_job" attribute="cmd" value="remove"/>.
        </li>
        <li>
            <scheduler_element name="job" attribute="replace" value="yes"/>
            ersetzt einen Job. Das wirkt wie Löschen und Einfügen.
        </li>
    </ul>

    <p style="margin-top: 2em">
        Beim Hinzufügen oder Austausch eines Jobs gilt:
    </p>
    <ul class="big">
        <li>
            Ein gestoppter Job wird entstoppt.
        </li>
        <li>
            Die <scheduler_element name="run_time"/> wird neu ausgewertet.
            Die mit <scheduler_element name="period" attribute="repeat"/> eingestellte Wiederholungszeit wird erneut berechnet,
            der Job startet, wenn er in einer solchen Periode ist, sofort.
        </li>
        <li>
            Die Verzögerung wegen <scheduler_element name="delay_after_error"/> geht verloren,
            der Verzögerungszähler beginnt wieder von vorn.
        </li>
        <li>
            Das Jobprotokoll wird fortgeschrieben.
        </li>
        <li>
            <scheduler_method class="Job" property="state_text"/> wird übernommen?
        </li>
        <li>
            ...
        </li>
    </ul>



    <h3>Jobketten</h3>

    <p>
        Jobketten können bereits jetzt gelöscht werden.
    </p>
    <p>
        Beim Austausch einer Jobkette übernimmt der Scheduler Aufträge aus Jobkettenknoten,
        die (mit gleichem Status) auch in der neuen Jobkette bekannt sind.
        Andere Aufträge gehen verloren. 
        Sie bleiben aber in der Datenbank, falls sie dort gespeichert worden sind.
    </p>
    <p>
        Das Kommando <scheduler_element name="job_chain"/> wird entsprechend geändert,
        sodass es diese Funktionalität hat.
    </p>
    
    <p>
        Der Austausch einer Jobkette wirkt anders als das Löschen und Wiedereinfügen.
        Bei letzteren werden die Aufträge aus der Datenbank wiederhergestellt, 
        was natürlich nur funktioniert, wenn sie dort gespeichert worden sind 
        (<scheduler_element name="job_chain" attribute="orders_recoverable" value="yes"/>).
    </p>

    <p style="color: red">
        Was passiert mit dem Zustand der Jobkette. 
        Soll eine gestoppte Jobkette gestoppt bleiben oder fortgesetzt werden?
    </p>

    <p style="color: red">
        Wie gehen wir mit Aufträgen um, die nicht in einer Jobkette, sondern nur im Job stehen?
        Man könnte diese Funktion ausbauen, braucht anscheinend eh keiner.
        Ansonsten müsste man solche Aufträge weiterhin im Job speichern, 
        und man hätte zwei Auftragsspeicher: Jobkettenknoten und Job.
    </p>
    
    <h3>Daueraufträge</h3>

    <p>
        Das sind ganz normale Aufträge, die als <scheduler_element name="order"/> in eigenen Dateien gehalten und
        durch <scheduler_element name="run_time"/> ständig im Scheduler vorgehalten werden.
        Hinzufügen, Ersetzen und Löschen wirken wie
        die Kommandos <scheduler_element name="add_order"/> und <scheduler_element name="remove_order"/>.
    </p>
    <p>
        Eine gelöschte oder geänderte Auftragsdatei wird nur beachtet, 
        wenn die Jobkette aktiv (<code>state=running</code>) ist und
    </p>
    <ul>
        <li>
            der Auftrag nicht bekannt,
        </li>
        <li>
            der Auftrag noch nicht gestartet worden oder
        </li>
        <li>
            der Auftrag wegen <scheduler_element name="run_time"/> wiederholt, aber noch nicht gestartet worden ist.
        </li>
    </ul>
    <p style="color: red">
        Was machen wir mit Aufträgen, die sich nicht wiederholen?
        Der Scheduler würde sofort die Auftragsdatei lesen und den Auftrag ohne Pause erneut starten.
        Wir müssen den Auftrag auf eine Art schwarzer Liste setzen 
        (die gibt es jetzt nur für Dateiaufträge und könnte vielleicht erweitert werden).
    </p>
    
    <h3>Prozessklassen</h3>

    <p>
        Prozessklassen können im laufenden Betrieb ausgetauscht werden.
        Der Austausch wird sofort vorgenommen.
    </p>

    <p>
        Löschen der Datei wirkt wie <scheduler_element name="process_class.remove"/>.
    </p>

    <h3>Sperren</h3>
    <p>
        Sperren können im laufenden Betrieb ausgetauscht werden.
        Der Austausch wird sofort vorgenommen, 
        der Zustand der Sperre (welche Jobs belegen die Sperre) bleibt erhalten.
    </p>
    <p>
        Eine gelöschte Sperrendatei wirkt wie <scheduler_element name="lock.remove" attribute="force" value="yes"/>.
        Das Attribut <code>force="yes"</code> wird neu realisiert und beendet alle <scheduler_element name="lock.use"/>,
        stoppt also alle Jobs.
    </p>
    <p style="color: red">
        Das Verhalten von <scheduler_element name="lock.remove"/> ist uneinheitlich mit <scheduler_element name="process_class.remove"/>.
        Ersteres liefert einen Fehler, wenn noch Jobs laufen, letzteres beendet die Jobs selbst.
        Das ist verwirrend.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Zusammengefasst: Was beim Ändern oder Löschen einer Datei geschieht</h2>

    <div class="max_width">
        <table cellspacing="0" cellpadding="0">
            <tr>
                <th style="padding-right: 2ex">
                    Datei
                </th>
                <th style="padding-right: 2ex">
                    Geändert
                </th>
                <th>
                    Gelöscht
                </th>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.job.xml</code>
                </td>
                <td style="padding-top: 0.5em; " colspan="2">
                    Der Scheduler beendet laufende Tasks und verhindert neue.
                    Sobald keine Tasks mehr laufen, tauscht er den Job aus, 
                    wobei einige Einstellungen erhalten bleiben (z.B. <scheduler_method class="Job" property="title"/>),
                    bzw. löscht ihn.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.job_chain.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    Die Aufträge der Jobkettenknoten werden übernommen.
                    Aufträge in Jobkettenknoten, die die ausgetauschte Jobkette nicht kennt,
                    gehen verloren bzw. bleiben in der Datenbank.
                </td>
                <td>
                    Wie <scheduler_element name="job_chain.remove"/>.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.order.xml</code>
                </td>
                <td style="padding-top: 0.5em;" colspan="2">
                    Die geänderte Datei wird nur beachtet, 
                    wenn der Auftrag noch nicht gestartet oder nicht vorhanden ist.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.process_class.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    Die Prozessklasse wird sofort geändert.
                </td>
                <td>
                    Alle Jobs werden beendet.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    ...<code>.lock.xml</code>
                </td>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    Die Sperre wird sofort geändert.
                    <div style="color: red">
                        Funtioniert nicht, wenn <code>max_non_exclusive</code> zu klein ist.
                    </div>
                </td>
                <td style="color: red">
                    Alle Jobs werden beendet?
                </td>
            </tr>
        </table>
    </div>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>Referenzen auf fehlende Objekte</h2>

    <p>
        Der Scheduler wird mit fehlenden Objekten umgehen können.
        Die referenzierten Objekte sind dann unvollständig und deshalb nicht in Betrieb.
    </p>
    <p>
        Fehlende referenzierte Objekte werden vom Scheduler automatisch eingefügt und als <i>vermisst</i> gekennzeichnet.
        Ein Objekt, das von einem vermissten anderen Objekt abhängt, wird nicht aktiv.
    </p>
    <p>&#160;</p>

    <div class="max_width">
        <table cellspacing="0" cellpadding="0">
            <tr>
                <th style="padding-right: 2ex">
                    XML-Element
                </th>
                <th>
                    Verhalten, wenn referenziertes Objekt vermisst wird
                </th>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="job" attribute="process_class"/>
                </td>
                <td>
                    Der Job ist <i>unvollständig</i> und startet nicht.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="job_chain_node" attribute="job"/>
                </td>
                <td>
                    Der Jobkettenknoten ist <i>unvollständig</i>. 
                    Aufträge stauen sich im Knoten.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="job_chain_node.job_chain" attribute="job_chain"/>
                </td>
                <td>
                    Der Jobkettenknoten ist <i>unvollständig</i>.
                    Aufträge stauen sich im Knoten.
                    Das ist eine neue Situation, weil bisher Aufträge nicht in der übergeordneten Jobkette stehen,
                    nur in den untergeordneten.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="order" attribute="job_chain"/>
                </td>
                <td>
                    Einen vermissten Auftrag, also einen ohne Jobkette, kann es nicht geben,
                    weil der Scheduler eine Auftragsdatei nur liest, 
                    wenn dessen Jobkette definiert ist.
                </td>
            </tr>
            <tr>
                <td style="padding-top: 0.5em; padding-right: 2ex">
                    <scheduler_element name="lock.use" attribute="lock"/>
                </td>
                <td>
                    Der Job ist <i>unvollständig</i> und startet nicht.
                </td>
            </tr>
        </table>
    </div>
    
    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

</description>
