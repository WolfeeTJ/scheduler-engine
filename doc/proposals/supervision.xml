<?xml version="1.0"?>
<?xml-stylesheet href="../scheduler.xsl" type="text/xsl"?>

<!--$Id$-->

<description
    title               = "Überwachung mehrerer Scheduler mit Ereignissen"
    base_dir            = "../"
    parent_page         = "index.xml"
    author              = "$Author$"
    date                = "$Date$"
>

    <p>
        In Kürze:
    </p>
    
    <ul>
        <li>
            Der Scheduler wird über eine TCP-Verbindung fortlaufend über auftretende Ereignisse berichten.
        </li>
        <li>
            Der überwachende Scheduler (Supervisor) sammelt die Ereignisse mehrerer Scheduler.
        </li>
        <li>
            Er liefert die Ereignisse als einzelne Aufträge an eine Jobkette.
        </li>
        <li>
            Und er liefert sie an den Java-Monitor.
        </li>
        <li>
            Der Supervisor kann eingestellt werden, welche Ereignisse berücksichtigt werden sollen.
        </li>
        <li>
            Der Supervisor kann Stellvertreter benennen, die in bei Nichterreichbarkeit ersetzen.
        </li>
        <li>
            Der Scheduler bekommt eine Zustandsdatei, worin er die vom Supervisor angebenen Stellvertreter einträgt.
        </li>
        <li>
            Die Ereignisse werden später auch als SNMP-Traps berichtet.
        </li>
    </ul>
    

    <h2>Überwachter Scheduler</h2>
    <p>
        Erweiterungen zu <scheduler_element name="config" attribute="main_scheduler"/>
    </p>
    <p>
        Der Scheduler verbindet sich wie bisher mit dem angegebenen Supervisor.
        Dieser antwortet mit 
    </p>
    <ul>
        <li>
            der Liste seiner Stellvertreter, die der Scheduler in seiner neuen Zustandsdatei speichert, 
        </li>
        <li>
            der Liste der Ereignistypen, die der Scheduler dem Supervisor melden soll, und
        </li>
        <li>
            der Frist ohne Ereignisse, innerhalb der der Scheduler ein Lebenszeichen geben soll.
        </li>
    </ul>

    <h3>Stellvertreter</h3>
    <p>
        Kann der Scheduler sich nicht mit dem Supervisor verbinden,
        und ist die Adresse des Supervisors dieselbe wie in der Statusdatei (also vom letzten Lauf des Schedulers),
        dann verwendet der Scheduler die in der Statusdatei eingetragenen Stellvertreter.
        Die Stellvertreter werden ignoriert, wenn die Adresse des Supervisors nicht dieselbe ist.
        <!--Bei Misserfolg probiert er die Stellvertreter der Reihe nach und beginnt dann wieder mit dem Supervisor
        (nach einer Atempause von einer Minute).-->
    </p>
    <!--p>
        Ebenso verfährt der Scheduler, wenn die Verbindung zum Supervisor oder einem Stellvertreter abreißt.
    </p-->

    <h3>Zustandsdatei</h3>
    <p>
        Im Verzeichnis <scheduler_option name="log-dir"/> hält der Scheduler die Datei <code>state-<i>scheduler_id</i>.xml</code>.
        Darin ist der zuletzt eingestellte Supervisor mit seinen Stellvertretern eingetragen.
    </p>

    <h3>Ereignissstrom</h3>
    <p>
        Sobald die Verbindung zum Supervisor (oder seinem Stellvertreter, was nicht unterschieden wird) steht,
        und dieser Ereignisse bestellt hat,
        meldet der Scheduler jedes Ereignis mit einem XML-Element <code>&lt;event></code>.
        Das ist ein kontinuierlicher Strom von XML-Elementen, die der Supervisor nicht beantwortet 
        und nicht unterbrechen kann.
    </p>
    <p>
        Wenn die Verbindung zu einem Supervisor abreißt,
        versucht der Scheduler die Verbindung erneut aufzubauen, 
        um den Ereignisstrom an der unterbrochenen Stelle fortzusetzen.
    </p>
    <p>
        Der Scheduler schreibt den Ereignisstrom in die Ereignisdatei 
        <code>events-<i>scheduler_id</i>-<i>yyyy</i>-<i>mm</i>-<i>dd</i>-….xml</code>
        (im Verzeichnis <scheduler_option name="log-dir"/>).
    </p>

    <h3>Pufferung des Ereignisstroms</h3>
    <p>
        Wenn ein Supervisor nicht verbunden oder die TCP-Verbindung nicht schnell genug ist
        (wegen Netzwerkengpasses oder zu langsamen Supervisors),
        staut der Scheduler die XML-Elemente.
    </p>
    <p>
        Ein kleiner Stau wird in einem Puffer von 100KB (pro Verbindung) aufgefangen.
    </p>
    <p>
        Ein größerer Stau wird mit der Ereignisdatei aufgefangen.
        Dazu wird für die Verbindung eine temporäre Datei geöffnet,
        die abwechselnd die Zahl der zu übertragenden und der herauszufilternden Bytes enthält.
    </p>
    <!--p> 
        Bei einem längeren Stau greift der Scheduler auf die Ereignisdatei zurück.
        Dazu hält er für jedes gestaute XML-Element Position und Länge (16 Byte),
        bei einer Begrenzung auf 1.000.000 Sätze wären das 16MB pro Verbindung.
        Bei mehr gestauten Sätzen g
    </p-->
    

    <h3>Lebenszeichen</h3>
    <p>
        Tritt eine Zeit lang kein Ereignis ein,
        dann schickt der Scheduler zur Prüfung der Verbindung ein Leerzeichen.
        Der Supervisor gibt die Frist vor.
    </p>


    <h2>Supervisor</h2>
    <p>
        Jeder Scheduler kann Supervisor sein.
        Er wird es dadurch, dass ein anderer Scheduler ihn mit 
        <scheduler_element name="config" attribute="main_scheduler"/> angibt.
    </p>

    <p>
        Der Supervisor nimmt Verbindungen der Scheduler an und kann Ereignisströme anfordern.
        Er versieht jedes XML-Element des Ereignisstroms mit einem Attribut, 
        das die Herkunft des Ereignisses angibt.
    </p>

    <h3>Vom Supervisor generierte Ereignisse</h3>
    <p>
        Bei Verbindungsaufbau und -abbau erzeugt der Supervisor je ein Ereignis.
    </p>

    <h3>Jedes Ereignis ist ein Auftrag</h3>
    <p>
        <!--Das neue Element <scheduler_element name="scheduler_event_source"/-->
        Eine Jobkette kann angegeben werden, die der Scheduler mit Ereignissen füttern soll.
        <scheduler_method class="Order" property="xml_payload"/> enthält das jeweilige Ereignis.
    </p>
    <pre>&lt;main_scheduler feed_job_chain="<i>job_chain</i>"></pre>
    <!--pre>&lt;job_chain name="…">
    &lt;scheduler_event_source/>
    &lt;job_chain_node …/>
&lt;/job_chain></pre-->
    <p>
        Die Jobkette kann zur Beschleunigung ohne Datenbank betrieben werden
        (<scheduler_element name="job_chain" attribute="orders_recoverable" value="no"/>).
    </p>


    <h3>Pufferung der Ereignisse</h3>
    <p>
        Der Supervisor puffert ebenso wie die Scheduler die Ereignisse in einer Datei.
        Der Puffer dient zur Fütterung der Jobkette, wenn die Jobs die Ereignisse nicht schnell genug verarbeiten,
        und zur Versorgung der Monitore.
    </p>


    <h3>Auswahl der Ereignisse (Filterung)</h3>
    <p>
        Welche Ereignisse die Scheduler melden sollen,
        wird in der XML-Konfiguration des Supervisor bestimmt.
    </p>
    <!--pre>&lt;main_scheduler>
    &lt;select_events object_type="Scheduler"/>
    &lt;select_events object_type="Job"/>
    &lt;select_events object_type="Task"/>
    &lt;select_events object_type="Order"/>
&lt;/main_scheduler></pre>
    <p>
        Oder kurz:
    </p-->
    <!--pre>&lt;main_scheduler>
    &lt;select_events object_type="Scheduler Job Task Order"/>
&lt;/main_scheduler></pre>
    <p>
        Noch kürzer:
    </p-->
    <pre>&lt;main_scheduler>
    &lt;get_events/>
&lt;/main_scheduler></pre>

    <h3>Mögliche Erweitung der Auswahl</h3>
    <p>
        Sollen vielleicht einzelne Jobs ausgewählt werden?
    </p>
    <pre>&lt;main_scheduler>
    &lt;get_events>
        &lt;select_events job="mein_job"/>
        &lt;select_events job="ein_anderer_job"/>
    &lt;/get_events>
&lt;/main_scheduler></pre>
    <p>
        Oder nur bestimmte Ereignisse? 
    </p>
    <pre>&lt;main_scheduler>
    &lt;get_events>
        &lt;select_events event_type="task_started"/>
    &lt;/get_events>
&lt;/main_scheduler></pre>

    <p>
        <i>Soll die Auswahl so aussehen?</i>
    </p>
    <p>
        Die Benennung der Attribute orientiert sich an die XML-Elemente für den eMail-Versand mit XSLT.
    </p>



    <h3>Tunnel zu den Schedulern</h3>
    <p>
        Der Supervisor stellt Tunnel zu den angeschlossenen Schedulern bereit,
        durch die Kommandos gereicht werden können.
    </p>
    <pre>&lt;tunnel_command from_scheduler_ip="<i>ip_number</i>" to_scheduler_id="…">
    &lt;<i>some_command</i>> … &lt;/<i>some_command</i>>
&lt;/tunnel_command></pre>
    <p>
        Die Antwort ist dann in <scheduler_element directory="xml/answer/" name="spooler" child="answer"/> 
        des Supervisor verpackt:
    </p>
    <pre>&lt;spooler>
    &lt;answer time="<i>main_scheduler_clock</i>">
        &lt;spooler>
            &lt;answer time="<i>scheduler_clock</i>">
                &lt;<i>some_answer</i>> … &lt;/<i>some_answer</i>>
            &lt;/answer>
        &lt;/spooler>
    &lt;/answer>
&lt;/spooler></pre>

    <p>
        (Der Supervisor wickelt die Tunnelung asynchron ab, er blockiert also nicht während der Kommandoausführung.)
    </p>

    <h3>Schutz</h3>
    <p>
        Der ausführende Scheduler führt das Kommando mit der Schnittmenge der Rechte
        des mit <code>from_scheduler_ip</code> angegebenen Schedulers und des Supervisors aus.
    </p>



    <h3>Stellvertreter des Supervisors</h3>
    <p>
        Der Supervisor kann Vertreter benennen.
        Die überwachten Scheduler verbinden sich mit allen Stellvertretern.
        Der Monitore verbindet sich mit einem Stellvertreter, wenn der Supervisor ausgefallen ist.
    </p>
    <pre>&lt;main_scheduler>
    &lt;main_scheduler_proxy proxy="…"/>
    &lt;main_scheduler_proxy proxy="…"/>
&lt;/main_scheduler></pre>


    

    <h2>Monitor</h2>
    <p>
        Der Monitor ist ein Dialogprogramm, 
        das sich mit einem Supervisor verbindet,
        um von ihm kontinuierlich Informationen über die Zustände der laufenden Scheduler zu erhalten.
    </p>

    <h3>Ereignisse</h3>
    <p>
        Dazu schickt er das Kommando <scheduler_element name="get_events"/>,
        das der Scheduler mit einer Kennung und der endlosen Folge von Ereignissen beantwortet.
        Die TCP-Verbindung ist von der Antwort belegt und kann nicht für andere Kommandos benutzt werden.
    </p>
    <p>
        Der Monitor kann angeben, von welchen Schedulern er die Ereignisse wünscht.
    </p>
    <pre>&lt;get_events with_null_byte="yes">
    &lt;select_events spooler_id="…"/>
&lt;/get_events></pre>

    <p>
        Der Supervisor antwortet mit der zunächst nicht endenden Folge
    </p>
    <pre>&lt;events>
    &lt;event …/>
    &lt;event …/>
    …</pre>
    <p>
        Das Attribute <code>with_null_byte</code> lässt jedes Element 
        <scheduler_element name="event"/> 
        mit einem 0-Byte abschließen 
        (nicht XML-konform, aber erleichtert das Parsieren).
    </p>
    <p>
        Der Monitor kann, ohne das Ende der Folge abzuwarten, ein weiteres Kommando geben, 
        z.B. ein anderes <code>&lt;get_events></code>.
        Der Supervisor schließt dann die Folge mit <code>&lt;/events></code>.
        Je nach Puffergrößen der Verbindung können vorher noch einige <code>&lt;event></code> eintreffen.
    </p>

    <h3>Stellvertreter</h3>
    <p>
        Der Monitor kann sich mit 
        <scheduler_element name="show_state"/> 
        die Liste der Stellvertreter vom Supervisor geben lassen,
        die er in einer Datei hält, um bei nicht erreichbarem Supervisor darauf zurückzugreifen.
    </p>


    <h2>Ereignisse</h2>
    <p>
        Die Scheduler liefern auf Bestellung kontinuierlich über eine eigene TCP-Verbindung 
        Informationen zu Zustandsänderungen, die Ereignisse.
    </p>
    <p>
        Die Ereignisse sollen auch als SNMP-traps geliefert werden können.
    </p>


    <h3>Scheduler-Ereignisse</h3>
    <dl>
        <dt><code>&lt;event event_type="<b>scheduler_started</b>"/></code></dt>
        <dd>
            Der Scheduler ist bereit 
        </dd>
        
        <dt><code>&lt;event event_type="<b>scheduler_stopped</b>"/></code></dt>
        <dd>
            Der Scheduler wird beendet
        </dd>
        
        <dt><code>&lt;event event_type="<b>scheduler_suspended</b>"/></code></dt>
        <dd>
            Der Scheduler ist angehalten
        </dd>
        
        <dt><code>&lt;event event_type="<b>scheduler_continued</b>"/></code></dt>
        <dd>
            Der Scheduler wird fortgesetzt
        </dd>
        
        <dt><code>&lt;event event_type="<b>database_error</b>"/></code></dt>
        <dd>
            Problem mit der Datenbank ...
        </dd>
    </dl>
    
    
    <h3>Job-Ereignisse</h3>
    
    <dl>
        <dt><code>&lt;event event_type="<b>job_add_delayed</b>" job="<i>name</i>"/></code></dt>
        <dd>
            Job soll hinzugefügt werden (<scheduler_element name="job"/>)
        </dd>
        
        <dt><code>&lt;event event_type="<b>job_added</b>" job="<i>name</i>"/></code></dt>
        <dd>
            Job ist hinzugefügt worden
        </dd>
        
        <dt><code>&lt;event event_type="<b>job_remove_delayed</b>" job="<i>name</i>"/>
            </code>
        </dt>
        <dd>
            Job soll entfernt werden
        </dd>

        <dt>
            <code>
                &lt;event event_type="<b>job_removed</b>" job="<i>name</i>"/>
            </code>
        </dt>
        <dd>Job ist entfernt worden</dd>
    </dl>


    <h3>Task-Ereignisse</h3>

    <dl>
        <dt>
            <code>
                &lt;event event_type="<b>task_started</b>">&lt;task job="<i>name</i>" task="<i>id</i>"/>&lt;/event>
            </code>
        </dt>
        <dd>
            Task startet
        </dd>

        <dt>
            <code>
                &lt;event event_type="<b>task_ended</b>">&lt;task job="<i>name</i>" task="<i>id</i>"/>&lt;/event>
            </code>
        </dt>
        <dd>Task hat geendet</dd>

        <dt><code>&lt;event event_type="<b>task_waiting</b>">&lt;task job="<i>name</i>" task="<i>id</i>"/>&lt;/event></code></dt>
        <dd>Task macht eine Pause (Zustand <code>suspended</code>, <code>running_waiting_for_order</code>, <code>running_delayed</code>)</dd>
    </dl>


    <h3>Auftrags-Ereignisse</h3>
    
    <dl>
        <dt><code>&lt;event event_type="<b>order_added</b>">&lt;order job_chain="<i>name</i>" order="<i>id</i>" state="…" title="…"/>&lt;/event></code></dt>
        <dd>
            Ein Auftrag ist in eine Jobkette gestellt worden.
        </dd>

        <dt><code>&lt;event event_type="<b>order_state_changed</b>">&lt;order job_chain="<i>name</i>" order="<i>id</i>" state="…" title="…"/>&lt;/event></code></dt>
        <dd>
            Der Zustand des Auftrags wechselt.
        </dd>

        <dt><code>&lt;event event_type="<b>order_step_startet</b>">&lt;order job_chain="<i>name</i>" order="<i>id</i>" state="…" title="…"/>&lt;/event></code></dt>
        <dd>
            Eine Task beginnt, den Auftrag auszuführen
        </dd>

        <dt><code>&lt;event event_type="<b>order_step_finished</b>">&lt;order job_chain="<i>name</i>" order="<i>id</i>" state="…" title="…"/>&lt;/event></code></dt>
        <dd>
            Eine Task hat den Auftrag ausgeführt (mit Wechsel des Zustands)
        </dd>

        <dt><code>&lt;event event_type="<b>order_suspended</b>">&lt;order job_chain="<i>name</i>" order="<i>id</i>" state="…" title="…"/>&lt;/event></code></dt>
        <dd>
            Der Auftrag ist angehalten.
        </dd>

        <dt><code>&lt;event event_type="<b>order_finished</b>">&lt;order job_chain="<i>name</i>" order="<i>id</i>" state="…" title="…"/>&lt;/event></code></dt>
        <dd>
            Der Auftrag ist ausgeführt und wird entfernt.
        </dd>
    </dl>


    
    <h2>Implementierung</h2>

    <h3>Ereignisse</h3>
    <ul>
        <li>
            Ein Modul für Ereignisse, zusammengefasst mit den bereits implementierten eMail-Ereignissen.
        </li>
        <li>
            Jedes Ereignis wird in die Ereignisdatei geschrieben. 
            Abschließendes <code>\n</code> kann durch <code>\0</code> ersetzt werden.
        </li>
    </ul>

    <h3>Verbindungen zu Supervisoren</h3>
    <ul>
        <li>
            Scheduler baut Verbindung zum Supervisor auf.
        </li>
        <li>
            Wenn das nicht geht, probiert er der Reihe nach die in der Zustandsdatei gespeicherten Stellvertreter.
        </li>
        <li>
            Wenn die Verbindung zu einem Supervisor steht, lässt der Scheduler sich die Stellvertreter geben.
        </li>
        <li>
            Der Scheduler baut zu jedem Stellvertreter eine Verbindung auf.
            Wenn es nicht geht, probiert er es endlos weiter.
            Ebenso versucht er nach einem Verbindungsabbruch die Verbindung wieder aufzubauen.
        </li>
        <li>
            Für jede Verbindung zu einem Stellvertreter hat der Scheduler einen Ereignis-Filter
            und eine Position in der Ereignisdatei.
        </li>
        <li>
            Der Scheduler hat direkten Zugriff auf die letzten 10.000 Ereignisse in der Ereignisdatei,
            für den Fall, dass die Ereignissmeldungen dem Supervisor nicht schnell genug übergeben werden können.
            Für den direkten Zugriff wird ein Ring mit 10.000 Dateizeigern realisiert (80KB).
        </li>
        <li>
            Der Scheduler hält für jede Verbindung eine Bitmap der noch nicht übertragenen Ereignisse,
            die festhält, welche gepufferten Ereignisse übertragen werden sollen.
            Die Bitmap verweist auf die Einträge des Dateizeigerrings und wird synchron mit ihm verschoben.
        </li>
        <li> 
            Wenn die ausstehende Übertragung der Ereignisse mehr die letzten 10.000 Ereignisse (ungefiltert) umfasst und 
            Ereignisse deshalb verloren gehen, 
            dann ersetzt der Scheduler die verloren gegangenen Ereignisse durch eine Ereignismeldung mit deren Anzahl.
            (Bei <scheduler_element name="get_events" attribute="ignore_lost_events" value="yes"/>, 
            sonst Abbruch des Kommandos mit Fehlermeldung.)
        </li>
        <li>
            Bei Scheduler-Ende alle gepufferten Ereignisse (immer: die Ereignisse der Scheduler-Beendigung) ausgeben.
            Wenn das länger dauert (>1s), eine Meldung ausgeben, damit man bescheid weiß.
            Wenn der Scheduler als Dienst beendigt wird, haben wir nur eine halbe Minute Zeit (festgelegt in spooler_service.cxx).
        </li>
    </ul>
    

    <h3>Supervisor</h3>
    <ul>
        <li>
            Verbindungsaufbau eines Job-Schedulers nach Abbruch der Verbindung mit demselben:
            Wenn ein <scheduler_element name="get_events"/> aktiv war, 
            wiederholt der Scheduler das Kommando und gibt mit <code>from=""</code> die Ereignisnummer an.
        </li>
    </ul>
    
    
    
</description>
