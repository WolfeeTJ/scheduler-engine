<?xml version="1.0"?>
<?xml-stylesheet href="../scheduler.xsl" type="text/xsl"?>

<!--$Id$-->

<description
    title               = "Verteilter Scheduler"
    base_dir            = "../"
    parent_page         = "index.xml"
    author              = "$Author$"
    date                = "$Date$"
    document_state      = "work_in_progress"
>
    
    <p>
        
    </p>

    <ul>
        <li>
            Mehrere Scheduler teilen sich die Aufgaben:
            Ausführung der Tasks und Aufträge.
        </li>
        <li>
            Die Scheduler können auf verschiedenen Rechnern laufen.
        </li>
        <li>
            Scheduler können während des Betriebs hinzugefügt und weggenommen werden.
        </li>
        <li>
            Alle Scheduler können gleich konfiguriert werden.
            Sie müssen dieselben Jobs und Jobketten haben.
        </li>
        <li>
            Jeder Scheduler liefert an der XML-Schnittstelle die gleichen Informationen
            bis vielleicht auf die aktuell ausgeführte Task (die nur in einem Scheduler läuft).
        </li>
    </ul>


    <p>
        Drei Verfahren sind denkbar. 
        Ich betrachte nur Aufträge, keine Tasks.
        Tasks könnten ähnlich abgewickelt werden (bis auf <scheduler_element name="run_time"/>-Starts).
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>A) Koordinierung durch Datenbank-Transaktion</h2>

    <p>
        Die Auftragswarteschlangen und die Schwarze Liste (für suspendierte Aufträge im Endzustand) werden ausschließlich in der Datenbank gehalten.
        Die Scheduler entnehmen der Datenbank den nächsten auszuführenden Auftrag auf folgende Weise:
    </p>


    <p>
        Die sichere Lösung erfordert eine Transaktion, die den Jobschritt überspannt.
        Weil der Scheduler den Jobschritt asynchron ausführt, 
        also während der Ausführung andere Aufgaben ausführen kann,
        muss eine zweite Datenbankverbindung geöffnet werden.
        Das ist so, als würde der Job selbst (in seinem Prozess) eine Datenbankverbindung öffnen.
        Der Scheduler hält einen Pool verfügbarer Datenbankverbindungen vor.
        Für jede laufende Task wird eine Verbindung benötigt.
    </p>

    <ul>
        <li>
            Der erste Auftrag in der Warteschlange wird mit SQL gesperrt.
            Ob die Sperre wirkt, muss die Datenbank sofort mitteilen (nicht erst bei Commit).
        </li>
        <li>
            Der Auftrag wird mit Select gelesen
        </li>
        <li>
            Der Job-Schritt wird durchgeführt
        </li>
        <li>
            Der Zustand des Auftrags wechselt
        </li>
        <li>
            Commit
        </li>
    </ul>

    <p>
        Ein zweiter Scheduler, der dieselben Schritte durchführen will, kann den Satz nicht sperren.
        Er geht dann zum nächsten Satz über.
    </p>

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

    <h2>B) Koordinierung mit Datenbank ohne andauernde Transaktion</h2>
    <p>
        Ein lockeres Verfahren ohne extra Datenbankverbindungen und ohne Satzsperre.
    </p>

    <ul>
        <li>
            Die Aufträge werden ebenfalls nur noch in der Datenbank gehalten, nicht mehr im Speicher
            (d.h. auch bisher flüchtige Eigenschaften müssen in der Datenbank gehalten werden).
        </li>
        <li>
            Zum Auftrag ist vermerkt, welcher Scheduler ihn gerade ausführt
            "<i>scheduler_id</i><code>.</code><i>host</i><code>:</code><i>port</i>".
        </li>
    </ul>

    <h3>Identifikation der Scheduler-Instanzen und Herzschlag</h3>
    <p>
        (Die Begriffe sind noch unklar: verteilter Scheduler, Scheduler-Instanzen.)
    </p>
    
    <p>
        Jede Scheduler-Instanz, also Teilnehmer eines verteilten Schedulers,
        bekommt den Namen »<i>scheduler_id</i><code>.</code><i>host</i><code>:</code><i>port</i>«.
    </p>
    <p>
        Jede Scheduler-Instanz hat einen eigenen Datenbanksatz,
        den er regelmäßig (minütlich) mit einem Zeitstempel versieht (Herzschlag).
        <pre>update scheduler_instances
    set last_heart_beat=sysdate(), next_heart_beat="yyyy-mm-dd hh:mm:ss"
    where name="<i>scheduler_id</i><code>.</code><i>host</i><code>:</code><i>port</i>"</pre>
    </p>

    <h3>Vor der Ausführung eines Auftrags</h3>
    <p>
        Wenn ein Scheduler bereit ist, einen Auftrag auszuführen, 
        versucht er einen zu belegen:
    </p>
    <pre>select … from scheduler_orders  
    where spooler_id = "…" 
      and job_chain  = "…" 
      and state = "…" 
      and start_time &lt;= "…" 
      and not suspended
      and processing_scheduler_instance is null
    order by start_time, priority
    
update scheduler_orders  
    set processing_scheduler_instance = "…", 
        processing_since              = sysdate(),
        timeout_at                    = "…"
    where spooler_id = "…" 
      and job_chain  = "…" 
      and order_id   = "…"
      and processing_scheduler_instance is null 
      
commit</pre>
    <p>
        Bei Erfolg kann der Scheduler über den Auftrag verfügen.
    </p>

    
    <h3>Nach der Ausführung eines Auftrags</h3>
    <pre>update scheduler_orders  
    set processing_scheduler_instance = null, 
        processing_since              = null,
        timeout_at                    = null,
        state                         = "<i>new_state</i>"
    where spooler_id = "…" 
      and job_chain  = "…" 
      and order_id   = "…"
      and processing_scheduler_instance = "…"
      
commit</pre>

    <p>
        Wenn das fehlschlägt, weil (wegen Zeitüberschreitung) ein anderer Scheduler den Auftrag belegt hat
        (<code>processing_scheduler_instance</code> ist verändert worden), 
        dann schlägt der Scheduler Alarm (er sendet eine eMail).
    </p>
    
    <h3>Fristüberschreitung — Erkennung durch anderen Scheduler</h3>
    <p>
        Der ausführende Scheduler steht im Verdacht, stehengeblieben zu sein,
        wenn der Auftrag vom Scheduler belegt ist (<code>processing_scheduler_instance</code> gefüllt)
        und
    </p>
    <ul>
        <li>
            <code>scheduler_orders.timeout_at</code> ist überschritten, oder
        </li>
        <li>
            <code>scheduler_instances.next_heart_beat</code> ist überschritten
        </li>
    </ul>
    <pre>select ... from scheduler_orders, scheduler_instances
    where scheduler_orders.timeout_at > <i>now</i>  
        or ( scheduler_orders.processing_scheduler_instance == scheduler_instances.name  
             and scheduler_instances.next_heart_beat > <i>now</i> )</pre>
    <p>
        Ein anderer Scheduler kann das feststellen,
        wenn er selbst einen Auftrag ausführen will oder durch periodische Überwachung und
    </p>
    <ul>
        <li>
            eine eMail verschicken und dies im Auftrag vermerken;
            der Operateur kann dann eine Entscheidung treffen
        </li>
        <li>
            automatisch den Auftrag dem anscheinend stehengebliebenen Scheduler entziehen
            (<code>processing_scheduler_instance=null</code>),
            um ihn selbst auszuführen
            (wer das einstellt, sollte wissen was er tut).
        </li>
    </ul>

    <h3>Fristüberschreitung — Erkennung vom Scheduler selbst</h3>
    <p>
        Der Scheduler kann auch selbst prüfen, ob er eine Frist überschreitet.
        Nachdem er seinen Datensatz in <code>schedulers_instances</code> erneuert hat,
        prüft er, ob dies zu rechten Zeit geschehen ist.
        Wenn nicht, gibt's eine Warnung.
    </p>


    <h3>Neustart des ausführenden Schedulers</h3>
    <p>
        Wenn der einen Auftrag ausführende Scheduler abgebrochen und neu gestartet wird,
        gibt er alle von ihm belegten Aufträge frei (und meldet dies).
    </p>
    <pre>update scheduler_orders  
    set processing_scheduler_instance = null, 
        timeout_at = null
    where processing_scheduler_instance = "<i>me</i>" and order_id="…" …</pre>



    <!--ul>
        <li>
            Für den Job muss ein <scheduler_element name="job" attribute="timeout"/> angegeben sein.
        </li>
        <li>
            In den Datenbanksatz wird vermerkt, welcher Scheduler den Auftrag ausführt
            zusammen mit dem Ende der First, wann der Auftrag ausgeführt sein muss.
            Das Ende der First wird gebildet aus <code>timeout</code> des Jobs plus einer kleinen Nachfrist 
            für die längste Reaktionszeit des Schedulers (normalerweise Millisekunden, also vielleicht 10-60s).
            Außerdem wird eine Ausführungskennung zum Auftrag gespeichert.
            Die Ausführungskennung ist eindeutig dem Jobschritt zugeordnet.
        </li>
        <li>
            Am Ende des Jobschritts prüft der Scheduler, ob der Datenbanksatz noch dieselbe Ausführungskennung hat und löscht die Frist.
        </li>
        <li>
            Wenn aber die Ausführungskennung eine andere ist,
            also ein anderer Scheduler nach Fristablauf den Auftrag übernommen hat, schlägt der Scheduler Alarm.
            Das kann passieren, wenn zwei Scheduler mit verschiedenen Uhren arbeiten (vielleicht kann die Datenbankuhr genutzt werden)
            oder wenn die Ausführung des Auftrags die Frist überschreitet,
            der Scheduler also nach Ablauf des Job-Timeouts aus irgendeiner Ursache nicht dazu kommt, den Taskschritt zurückzusetzen.
        </li>
        <li>
            Für andere Scheduler ist der Auftrag solange gesperrt, wie die Frist läuft.
        </li>
        <li>
            Wenn nach Ablauf der Frist der Satz noch mit der Frist in der Datenbank steht,
            die Ausführung also begonnen, aber noch nicht geendet hat,
            wird dies von einem (allen?) anderen Scheduler dem Administrator gemeldet,
            der die Situation prüfen und den Auftrag freigeben kann.
        </li>
    </ul-->

    <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

</description>
