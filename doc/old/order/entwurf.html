<html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="ProgId" content="FrontPage.Editor.Document">
<style type="text/css">
h1           { font-size: 24pt; font-weight: bold; margin-bottom: 4ex;  }
h2           { font-size: 12pt; font-weight: bold; margin-top: 10ex; }
h3           { font-size: 10pt; font-weight: bold; margin-top: 6ex }
.zwischentitel { font-weight: bold; margin-top: 6ex }
td           { font-size: 10pt; margin-top: 2ex; margin-bottom: 0  }
p            { font-size: 10pt; margin-top: 2ex; margin-bottom: 0  }
li           { font-size: 10pt }
pre          { font-family: Lucida Console, monospace; font-size: 9pt; margin-left: 5mm; line-height: 1.2em; }
.indent      { margin-left: 5mm; }
.mono        { font-family: Lucida Console, monospace; font-size: 9pt }
</style>

<title>Spooler mit Jobketten - Entwurf</title>
</head>
<body>



<h1>Spooler mit Jobketten - Entwurf
</h1>

<p align="right">27. August 2002
</p>

<h2>Jobkette</h2>
<p>Die Jobketten werden im Spooler-Skript aufgebaut.&nbsp;</p>
<pre>&lt;spooler&gt;
    &lt;script&gt;
        set job_chain = spooler.create_job_chain(&quot;dokument_drucken&quot;)

        job_chain.add_job &quot;aufbereiten&quot;
        job_chain.add_job &quot;drucken&quot;
    &lt;/script&gt;
&lt;/job&gt;</pre>
<p>Bei einem Fehler in einem Jobschritt kann anderer Job ausgeführt werden:</p>
<pre>&lt;spooler&gt;
    &lt;script&gt;
        set job_chain = spooler.create_job_chain(&quot;dokument_drucken&quot;)

        job_chain.add_job &quot;aufbereiten&quot;
        <font color="#0000FF">job_chain.add_job_for_failure &quot;aufbereitungsfehler&quot;
</font>
        job_chain.add_job &quot;drucken&quot;
    &lt;/script&gt;
&lt;/job&gt;</pre>
<p>Statt eines Folgejobs soll auch eine andere Jobkette angebbar sein. Damit kann
man komplexe Strukturen aufbauen.
</p>
<p>Jeder Job in der Jobkette ist eine Position. Als Name der Position ist der
Jobname voreingestellt. Zusammen mit dem Namen der Jobkette ist der Name der
Position eindeutig. Syntax etwa &quot;<i>jobkette</i>/<i>position</i>&quot; oder
im Beispiel: &quot;<font class="mono">dokument_drucken/drucken</font>&quot;.
</p>
<p class="zwischentitel">Tabelle der Position
</p>
<p>Die Aufträge kennen selbst ihre Position in der Jobkette. Die Position muss
aber nicht in der vom Spooler gewünschten Form vorliegen. Eine Tabelle setzt
die Position (den Zustand), wie sie intern vom Auftrag verwendet wird in die
Position des Spoolers um. Das kann mit <font class="mono">add_obj()</font>
angegeben werden.
</p>
<pre>job_chain.add_job &quot;drucken&quot;, 400</pre>
<p>Der Zustand 400 eines Auftrags entspricht der Position vor dem Job
&quot;drucken&quot;.
</p>
<h2>Auftragsgesteuerter Job
</h2>
<p>Der Auftrag wird der neuen Methode <font  class="mono">spooler_order()</font> übergeben.
</p>
<pre>&lt;job name=&quot;aufbereiten&quot;&gt;
    &lt;script&gt;
        function spooler_open
            'Brauchen wir vielleicht nicht
        end function

        function spooler_order( order )
            aufbereiten order.record
        end function
    &lt;/script&gt;
&lt;/job&gt;</pre>
<p>Ein Job, der die Methode <font  class="mono">spooler_order()</font> 
implementiert, ist auftragsgesteuert. Die Methode ersetzt <font class="mono">spooler_process()</font>.
</p>
<p class="zwischentitel">Fehler bei spooler_order()
</p>
<p>Wie werden Fehler behandelt? Ein Fehler in <font  class="mono">spooler_process()</font> 
 führt zum Stopp des Jobs. Wenn der Fehler am Auftrag liegt, soll nur der
Auftrag als fehlerhaft markiert werden und der Job weiterlaufen. Wenn der Fehler
grundsätzlicher Art ist, zB die Datenbank nicht erreichbar ist, soll aber der
Job wie bisher stoppen. Die beiden Fehlerarten lassen sich idR nicht klar
voneinander unterscheiden oder der Implementierungsaufwand wäre zu hoch.
</p>
<p>Also: Ein Fehler in <font class="mono">spooler_order()</font> führt zu einem
fehlerhaften Auftrag, der Job wird nicht gestoppt. Vielleicht ist eine Anzahl
aufeinander folgender fehlerhafter Aufträge einstellbar, nach der der Job doch
gestoppt wird (<font class="mono">spooler_job.stop_after_errors=100</font>).
</p>
<p class="zwischentitel">Verzögertes Beenden der Task
</p>
<p>Nachdem der Job den letzten Auftrag ausgeführt hat, soll die Task nicht
unbedingt beendet werden (mit <font class="mono">spooler_close()</font>). Erst,
wenn eine einstellbare Wartezeit verstrichen ist, beendet der Spooler die Task
(um Ressourcen freizugeben).
</p>
<h2>Auftrag
</h2>
<p>Ein Auftrag hat eine Position in einer Jobkette.
</p>
<p>Wenn ein Job startet (seine Runtime es erlaubt), führt der Spooler dem Job
die Aufträge zu. Welche Aufträge das sind, erkennt der Spooler an der Position
des Auftrags. Der Job führt einen Jobschritt auf den Auftrag aus. Anschließend
setzt der Spooler die Position des Auftrags auf die nächste Stelle in der
Jobkette (abhängig vom Erfolg des Jobschritts).
</p>
<p>Die Position des Auftrags ist also eine beschreibbare Eigenschaft.
</p>
<p>Mit der geänderten Position des Auftrags steht der Auftrag dem nächsten Job
bereit.&nbsp;
</p>
<pre>class Dokumentauftrag

    property get spooler_<b>id</b>      'optional
        spooler_id = record.id
    end property
    
    property get spooler_<b>title</b>   'optional
        spooler_id = &quot;Dokument &quot; &amp; record.title
    end property

    property get spooler_<b>priority</b>   'optional
        spooler_priority = record.priority
    end property

    property get spooler_<b>position</b>
        set spooler_position = spooler.create_position( record.workflow, record.next_job )
    end property

    property let spooler_<b>position</b>( pos )
        <i>db</i>.put &quot;update tabelle set pos='&quot; &amp; pos &amp; &quot;' where key='&quot; &amp; record.key &amp; '&quot;
        <i>db</i>.put &quot;COMMIT&quot;   ? Die Transaktion überwacht besser der Spooler ?
    end property

    dim record      'Datensatz

end class</pre>
<p>Ein Job kann auch selbst die Position des Auftrags setzen und damit die
vorgegebene Reihenfolge der Jobkette ändern.
</p>
<p class="zwischentitel">Unterbrechung in der Jobkette / Verarbeitung außerhalb
des Spoolers
</p>
<p>Durch die Speicherung der Position im Auftrag kann eine Jobkette formuliert werden, in der eine Stelle nicht
durch einen Spooler-Job, sondern durch etwas Äußeres realisiert ist. Erst,
wenn diese äußere Verarbeitung den Zustand des Auftrags so weiterverändert
hat, dass er wieder auf einen Job der Jobkette passt, setzt der Spooler die
Verarbeitung fort. Die Äußere Verarbeitung kann auf einem anderen Rechner
stattfinden oder ein Eingriff des Benutzers sein.
</p>
<p>&nbsp;
</p>
<p>Aufträge werden dem Spooler mit der Methode <font class="mono">spooler_job.order_queue.add()</font>
oder über eine Auftragsquelle bekannt.
</p>
<h2>Auftragsliste
</h2>
<p>Auftragslisten werden vom Spooler im Speicher gehalten. Jeder
auftragsgesteuerte Job hat eine Auftragsliste. Der Job wird gestartet, sobald
die Auftragsliste nicht leer ist (oder einen Pegel überschreitet).
</p>
<p>Die Auftragsliste kann mit einem anderen Job gefüllt werden.
</p>
<pre>&lt;job name=&quot;lies_aufträge&quot;&gt;
    &lt;script&gt;
        function spooler_open
            file.open &quot;select * from aufträge where ... order by ...&quot;
        end function

        function spooler_close
            file.close
        end function

        function spooler_process
            if file.eof() then spooler_process = false : exit function
            <font color="#0000FF">spooler.job(&quot;</font>aufbereiten<font color="#0000FF">&quot;).order_queue.add</font> new Dokumentauftrag( file.get() )
            spooler_process = true
        end function
    &lt;/script&gt;
&lt;/job&gt;</pre>
<pre>&lt;job name=&quot;aufbereiten&quot;&gt;
    &lt;script&gt;
        function spooler_order( order )
            aufbereiten order.record
        end function
    &lt;/script&gt;
&lt;/job&gt;</pre>
<p class="zwischentitel">Standardisierte Auftragsklasse</p>
<p>Nicht für jede Auftragsklasse muss codiert werden. Standardisierte Aufträge
können auch direkt in die Auftragsliste eingefügt werden.</p>
<pre>set record = file.get()
spooler.job(&quot;aufbereiten&quot;).order_queue.add record, record.level, record.priority</pre>
<p>Die drei Parameter dieser Methode <font class="mono">add()</font> sind:</p>
<p>1) Ein Variant - wird vom Spooler durchgerecht, hier der Datensatz record</p>
<p>2) Die Position in einer Jobkette. Dazu wird dem Spooler zuvor per Skript
eine Tabelle übergeben, in der jedem Level (einer Zahl) eine Position in einer
Jobkette zugeordnet ist.</p>
<p>3) Die Priorität (optional).</p>
<h2>Auftragsquelle
</h2>
<p>Statt einen Job zu schreiben, der die Auftragsliste füllt, kann auch eine
Auftragsquelle formuliert werden.
</p>
<p>Eine Auftragsquelle ist ein Objekt mit den Methoden <font class="mono">open()</font>,
<font class="mono"> close()</font> und <font class="mono">get()</font>. Der
Spooler liest alle Aufträge mit <font class="mono">get()</font>, fügt sie der
Auftragsliste des zugeordneten Jobs zu und schließt die Auftragsquelle, bevor
ein Jobschritt ausgeführt und damit vielleicht die Datenbanktransaktion beendet
wird.
</p>
<p>Wenn alle Aufträge vom Job ausgeführt sind, werden die nächsten Aufträge
gelesen.
</p>
<p>Die Implementierung einer Auftragsquelle ist parametrisierbar, damit sie für
mehrere gleichartige Auftragsquellen benutzt werden kann.
</p>
<pre>&lt;order_source name=&quot;dokumentaufträge&quot;/&gt;
    &lt;script&gt;
        function spooler_open( param )
            file.prepare &quot;-in select * from dokumentaufträge where kind=? order by ...&quot;
            file.set_parameter 1, param
            file.open
        end function

        function spooler_close
            file.close
            set file = nothing
        end function

        function spooler_get
            set spooler_get = new Dokumentauftrag( file.get() )
        end function
    &lt;/script&gt;
&lt;/order_source&gt;</pre>
<h2>Ansicht
</h2>

<p>Über die TCP-Schnittstelle liefert der Spooler den Stand der Aufträge.
</p>

<p>Z.B.
</p>

<pre>&lt;show_state/&gt;</pre>

<pre>&lt;jobchains&gt;
    &lt;jobchain name=&quot;drucken&quot;&gt;
        &lt;task name=&quot;aufbereiten&quot; orderqueue_length=&quot;47&quot; order_errors=&quot;3&quot;/&gt;
    &lt;/jobchain&gt;
&lt;/jobchains&gt;</pre>

<h2>Verteilter Spooler
</h2>

<p>Aufträge sind Voraussetzung für den Verteilten Spooler. Denn die Aufträge
sind es, die zu den verschiedenen Spoolern verteilt werden.
</p>

<p>Dazu muss ein Auftrag übertragbar sein, also Methoden zur Konvertierung nach
und von XML haben.
</p>

<pre>class Dokumentauftrag

    property get spooler_xml
        spooler_xml = record.obj_xml
    end property

    property put spooler_xml( text )
        set record = <i>file</i>.create_record()
        record.obj_xml = text
    end property

    dim record      'Datensatz

end class</pre>
<p>Wer legt den Auftrag an, woher kommt <i>file</i>? Wenn Spooler A einen
Auftrag zu Spooler B schickt, legt Spooler B einen leeren Auftrag an und
übergibt ihm den XML-Text. Der Auftrag muss aber noch seinen Kontext kennen,
hier <i>file</i>.
</p>

<p>Der Auftrag wird also nicht freischwebend, sondern über seine Auftragsquelle
angelegt.
</p>

<pre>class Dokumentauftragsquelle

    function spooler_open
        set letter_file = hostware.open( &quot;sql -table=letters -sql-fields=(...) | &quot; &amp; db_name )
    end function

    function spooler_create_order
        set order = new Dokumentauftrag
        set order.file = letter_file
        set spooler_create_order = order
    end function

    dim letter_file

end class</pre>

<h2>Transaktionssteuerung
</h2>

<p>Wenn der Spooler die Position des Auftrags in der Jobkette weitersetzt, wer
beendet dann die Transaktion? Der Methode im Auftrag, die die Operation
durchführt, selbst?
</p>

<p>Besser, der Spooler beendet die Transaktion.
</p>

<p>Auch der Jobschritt macht kein Commit oder Rollback mehr. Das übernimmt der
Spooler: Bei Erfolg Commit, sonst Rollback. Vorteil: Man kann's nicht mehr
vergessen. Der Spooler muss dazu die Datenbankverbindungen (normalerweise ja nur
eine) kennen, deren Transaktionen er beenden soll.
</p>

<pre>set spooler_job.db = db</pre>

<p>oder, falls mehrere Datenbankverbindungen unterstützt werden sollen (nicht
so gut, weil die Transaktionen nicht koordiniert sind):
</p>

<pre>spooler_job.dbs.add db</pre>

<h2>Offene Fragen
</h2>

<p>Die Implementierung des Auftragsobjekts muss zwischen verschiedenen Scripting
Engines, die möglicherweise in verschiedenen Threads laufen, benutzbar sein.
</p>

<p>&nbsp;
</p>

<p>&nbsp;</p>

<HR SIZE=1>
<FONT face="Arial" size="2">Dipl.-Inform. Joacim Zschimmer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<A href="mailto:j@zsch.de">j@zsch.de</A>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;(030) 3470 2520&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Zschimmer GmbH</FONT>

</body>

</html>
