<?xml version="1.0"?>
<?xml-stylesheet href="changes.xsl" type="text/xsl"?>

<!--$Id: factory_ini.xml 3623 2005-04-20 06:53:16Z jz $-->

<changes title    = "Änderungsprotokoll"
         author   = "$Author: jz $"
         date     = "$Date: 2005-05-08 01:44:34 +0200 (So, 08 Mai 2005) $">

    <scheduler_keyword keyword="Änderungsprotokoll"/>
    <scheduler_keyword keyword="Change log"/>

    <change date="2005-08-10" version="2.0.135" subversion_revision="3824">
        <revision type="new" title="&lt;modify_order&gt; kann &lt;run_time&gt; ändern">
            <description>
                <p>
                    In <scheduler_element name="modify_order"/> kann jetzt
                    <scheduler_element name="run_time"/> gesetzt werden.
                </p>
            </description>
        </revision>
        
        <revision type="new" title="Methode Job_chain.add_or_replace_order() neu">
            <description>
                <p>
                    <scheduler_method class="Job_chain" method="add_or_replace_order" java_signature="sos.spooler.Order" />
                    wirkt wie 
                    <scheduler_method class="Job_chain" method="add_order" java_signature="sos.spooler.Order" />,
                    wenn die Jobkette keinen Auftrag mit gleicher Kennung hat.
                </p>
                <p>
                    Hat die Jobkette bereits einen Auftrag mit gleicher Kennung, dann wird dieser ersetzt.
                    Genauer: Er wird aus der Jobkette entfernt 
                    (wie mit <scheduler_method class="Order" method="remove_from_job_chain"/>),
                    und der neue Auftrag wird hinzugefügt.
                </p>
                <p>
                    Falls der ersetzte Auftrag gerade von einer Task ausgeführt wird,
                    dann wartet der Scheduler die Ausführung ab, bevor der neue Auftrag ausgeführt werden kann.
                </p>
                <p>
                    Siehe auch <scheduler_element name="add_order" attribute="replace" value="yes"/>.
                </p>
            </description>
        </revision>

        <revision type="modification" title="Methode Order.remove_from_job_chain() geändert">
            <description>
                <p>
                    (<scheduler_method class="Order" method="remove_from_job_chain"/> wirkt wie
                    <scheduler_element name="remove_order" />.)
                </p>
                <p>
                    Wenn der Auftrag gerade von einer Task ausgeführt wird,
                    liefert die Eigenschaft <scheduler_method class="Order" property="job_chain" /> 
                    weiterhin die Jobkette, aus der der Auftrag gerade entfernt wird.
                    Erst wenn die Ausführung beendet ist, liefert die Eigenschaft <code>null</code>
                    (außer der Auftrag ist wieder in eine Jobkette eingetragen worden).
                    Damit bleibt die Eigenschaft <code>job_chain</code> während der Ausführung durch die Task stabil.
                </p>
            </description>
        </revision>
        
        <revision type="correction" title="Java-Methode sos.spooler.id() liefert auch Integer als String">
            <description>
                <p>
                    Statt einem Cast (String) wird jetzt .toString() gerufen, 
                    sodass auch eine Auftragskennung die als Integer-Variant (o.dgl.) gespeichert ist, 
                    in Java als String geliefert wird.
                    (Bisher gab es eine ClassCastException.)
                </p>
            </description>
        </revision>
        
        <revision type="correction" title="let_run_terminate_and_restart beendet Tasks im Zustand running_waiting_for_order">
            <description>
                <p>
                    Siehe <scheduler_element name="modify_spooler" attribute="cmd" value="let_run_terminate_and_restart"/>.
                </p>
            </description>
        </revision>
        
    </change>

    <change date="2005-08-04" version="2.0.134" subversion_revision="3818">
        <revision type="correction" title="Klasse sos.spooler.Mail unter Unix/Java funktionsfähig">
            <description>
                <p>
                    Unter Unix in Java war die Klasse sos.spooler.Mail nicht benutzbar (Fehlercode COM-80020009  DISP_E_EXCEPTION).
                </p>
            </description>
        </revision>
    </change>

    <change date="2005-08-03" version="2.0.134" subversion_revision="3817">
        <revision type="correction" title="Order &lt;period single_start&gt; korrigiert">
            <description>
                <p>
                    Der nächste Single_start bei einem Auftrag mit 
                    <scheduler_element name="period" attrbute="single_start"/> 
                    wird jetzt korrekt ausgeführt.
                </p>
            </description>
        </revision>
    </change>

    <change date="2005-08-01" version="2.0.134" subversion_revision="3814">
        <revision type="new" title="Subprocess.termination_signal">
            <description>
                <p>
                    <scheduler_method class="Subprocess" property="termination_signal" /> 
                    liefert unter Unix 0 oder die Nummer des Signals, mit dem der Subprozess endete.
                </p>
                <p>
                    Unter Windows liefert die Methode 0.
                </p>
            </description>
        </revision>
    </change>

    <change date="2005-07-30" version="2.0.134" subversion_revision="3812">
        <revision type="new" title="delay_after_error erzeugt neue Task">
            <description>
                <p>
                    Eine Task, für die nach einem Fehler 
                    <scheduler_method class="Job" property="delay_after_error" java_signature="int, double" access="write"/> 
                    wirksam wird, 
                    fügt der Scheduler jetzt (mit neuer Kennung) erneut in die Task-Warteschlange ein.
                    Dabei werden die Task-Parameter übernommen.
                </p>
                <p>
                    Das gilt nicht für Auftragsjobs.
                    Für die wird wie bisher keine neue Task gestartet, 
                    denn der Start wird durch den evtl. anstehenden Auftrag angestossen.
                </p>
            </description>
        </revision>

        <revision type="new" title="Neues Attribut delayed_after_error_task im Antwort-XML-Element &lt;task&gt;">
            <description>
                <p>
                    Siehe <scheduler_element directory="xml/answer/" name="task" attribute="delayed_after_error_task"/>.
                </p>
            </description>
        </revision>
        
        <revision type="new" title="Neue Attribute delay_after_error= und in_period= im Antwort-XML-Element &lt;job&gt;">
            <description>
                <p>
                    Siehe <scheduler_element directory="xml/answer/" name="job" attribute="delay_after_error"/>
                    <br/>
                    und <scheduler_element directory="xml/answer/" name="job" attribute="in_period"/>.
                </p>
            </description>
        </revision>
        
    </change>

    <change date="2005-07-04" version="2.0.133" subversion_revision="3786">
        <revision type="new" title="XSLT-Stylesheets für eMails">
            <description>
                <p>
                    <scheduler_method class="Mail" property="xslt_stylesheet_path" java_signature="java.lang.String" access="write"/> 
                    setzt das XSLT-Stylesheet für eMails.
                </p>
                <example>
                    
                </example>
            </description>
        </revision>

        <revision type="new" title="Neue Klasse Xslt_stylesheet">
            <description>
                <p>
                    <scheduler_method class="Spooler" method="create_xslt_stylesheet" /> 
                    liefert ein <scheduler_method class="Xslt_stylesheet" />.
                </p>
            </description>
        </revision>
    </change>

    <change date="2005-06-25" version="2.0.132" subversion_revision="3743">
        <revision type="new" title="&lt;order_queue&gt; liefert Attribut next_start_time"/>
    </change>

    <change date="2005-06-24" version="2.0.130" subversion_revision="3742">
        <revision type="correction" title="Fehlendes &lt;run_time&gt; wird wieder wie leeres &lt;run_time/&gt; interpretiert"/>
    </change>

    <change date="2005-06-08" version="2.0.129" subversion_revision="3696">
        <revision type="modification" title="Auftragsjob stoppt bei return false in spooler_init() oder spooler_open()">
            <description>
                <p>
                    Ein Auftragsjob, der 
                    <code>false</code> in 
                    <scheduler_method class="Job_impl" method="spooler_init"/>
                    oder 
                    <scheduler_method class="Job_impl" method="spooler_open"/>
                    liefert,
                    wird mit Fehlermeldung gestoppt.
                </p>
                <p>
                    Das Stoppen kann mit 
                    <scheduler_method class="Job" property="delay_after_error" java_signature="int, double" access="write"/> 
                    verhindert werden.
                </p>
                <p>
                    Der Auftrag bleibt in der Auftragswarteschlange des Jobs 
                    und wird beim nächsten erfolgreichen Start des Jobs verarbeitet.
                </p>
            </description>
        </revision>
    </change>

</changes>
