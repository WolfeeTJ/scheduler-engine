<?xml version="1.0" encoding="utf-8"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com) by Andreas Pueschel (APL Software GmbH) -->

<?xml-stylesheet href="scheduler.xsl" type="text/xsl"?>
<!--$Id: job.xml 4950 2007-04-12 06:39:59Z fs $-->

<description  title="Externe Job-Verarbeitung"
              base_dir=""
              author="$Author: fs,ur $"
              date="$Date: 2007-04-20 16:39:59 +0200 (Fr, 20 Apr 2007) $">

    <scheduler_keyword keyword="Remote Execution"/>
    <scheduler_keyword keyword="Remote"/>
    <scheduler_keyword keyword="remote_scheduler"/>


    <p>
      API-Jobs können auf einem entfernten Job Scheduler ausgeführt werden. 
    </p>
    
    <p>
      Entfernt ausgeführte Jobs verhalten sich gegenüber dem aufrufenden Job Scheduler so wie lokal ausgeführte Jobs. 
      Lediglich die Rechenlast wird auf einen anderen Job Scheduler übertragen.
    </p>
    
    <p>
      Das bedeutet z.B., dass alle API-Aufrufe sich auf das lokale Job Scheduler Objekt beziehen.
    </p>
    
    <p>
      Die Protokollausgaben des Jobs, sowie der Endzustand und eventuelle Fehler werden an den 
      aufrufenden Job Scheduler geleitet.
    </p>
    
    
    
    <h2>Verwendung</h2>
    
    <p>
      Überwiegend werden Job Scheduler mit der Ausführung von Jobs beauftragt, die auf einem anderen physikalischen Rechner installiert sind.
    </p>
    <p>
      Beispiele für die Verwendung:
      
      <ol>
        <li>
          Das Verfahren dient dem Load Balancing.
        </li>
        <li>
          Es können Software-Installationen verwendet werden, die sich nicht auf dem lokalen Rechner befinden.
        </li>
        <li>
          Es können Hardware-Komponenten verwendet werden, die nur von einem anderen Rechner erreichbar sind (z.B. Drucker).
        </li>
      </ol>
    </p>
    
    
    
    <h2>Voraussetzungen</h2>
    
    <ol>
      <li>Einstellungen in der Firewall
        <p>
          Der lokale Job Scheduler muss den entfernten Job Scheduler erreichen können. 
          Alle Sicherheitseinstellungen in den Firewalls müssen das berücksichtigen. 
          Für die Kommunikation in Richtung entfernter Job Scheduler muss der Port des entfernten 
          Rechners in der Firewall freigeschaltet sein. 
          In der entgegengesetzten Richtung verbindet sich die Task mit dem aufrufenden Job Scheduler über 
          einen Port &lt;5999 abwärts zählend pro laufende Task.
          Entsprechend der erwarteten Anzahl Tasks müssen diese Ports in der Firewall freigeschaltet sein.
          <br/><br/>
        </p>
      </li>
      <li>
        Security-Einstellungen in der Job Scheduler Konfiguration
        <p>
          Der entfernte Job Scheduler muss im Security Element den aufrufenden Job Scheduler legitimieren. 
          <br/><br/>
          Beispiel
          <pre>
&lt;security ignore_unknown_hosts="no"&gt;
    &lt;allowed_host host="123.456.89.1" level="all"/&gt;
&lt;/security&gt;
          </pre>
        </p>
      </li>
      <li>
        Beide Job Scheduler müssen gestartet sein.
      </li>
    </ol>
    
    
    
    <h2>Konfiguration</h2>
    
    <p>
      Die Job-Definition steht in der Konfigurationsdatei des lokalen, aufrufenden Job Scheduler.<br/>
      Um einen Job auf einem anderen Job Scheduler ausführen zu lassen, sind beim lokalen, 
      aufrufenden Job Scheduler folgende Konfigurationen nötig:
    </p>
    <p>
      <ol>
        <li>
          Es muss eine Prozessklasse angelegt werden,
          und in ihr das Attribut <scheduler_element name="process_class" attribute="remote_scheduler" value=""/>
          gesetzt sein.
          Dadurch werden alle Jobs, die dieser Prozessklasse zugeordnet sind, extern ausgeführt.
          <br/><br/>
          Beispiel
          <pre>
&lt;process_classes&gt;
    &lt;process_class name="remote"
                   max_processes="3"
                   remote_scheduler="remoteHost:4445"/&gt;
&lt;/process_classes&gt;
          </pre>
        </li>
        <li>
          Der Job muss der Prozessklasse zugeordnet werden,<br/>
          siehe <scheduler_element name="job" attribute="process_class"/>
        </li>
      </ol>
    </p>
    
    
    
    <h2>Monitor-Script</h2>
    
    <p>
      Die zu einem Job gehörenden Monitor-Scripte werden ebenfalls am entfernten Job Scheduler ausgeführt. 
      So gibt z.B. dieses Testscript den Rechnernamen des entfernten Rechners aus.
      <pre>
function spooler_process_before() {
     spooler_log.info("host:tcp_port:" + spooler.tcp_port);
     var  localhost = new java.net.InetAddress.getLocalHost();
     hostname = localhost.getHostName();
     ip = localhost.getHostAddress();
     spooler_log.info("==>" + hostname + ":::"+ ip);
     return true;
  }
      </pre>
    </p>
    
    
    
    <h2>Kontext der API-Aufrufe</h2>
    
    <p>
      Alle API-Aufrufe beziehen sich auf den lokalen, aufrufenden Job Scheduler. 
      So liefert z.B. die Methode <pre>spooler.ini_path</pre> den Namen der 
      Datei <i>factory.ini</i> beim lokalen, aufrufenden Job Scheduler und nicht beim entfernten Job Scheduler zurück. 
      Dieser Dateiname steht möglicherweise beim entfernten Dateisystem nicht zur Verfügung. 
      Das Gleiche gilt für die Methode <pre>spooler.directory</pre> 
      denn die beiden Job Scheduler können unterschiedliche Basisverzeichnisse verwenden.
    </p>
    
    
    
    <h2>Konfigurations-Dateien></h2>
  
    <p>
      Alle Einstellungen werden beim lokalen, aufrufenden Job Scheduler gelesen.
    </p>
    
    <p>
      Einige Einstellungen werden vom entfernten statt vom lokalen, aufrufenden Job Scheduler übernommen:
    </p>
    <ul> 
      <li> sos.ini (Abschnitt [java], Eintrag javac=…)</li>
      <li> factory.ini (Abschnitt [spooler], Eintrag tmp=…)</li>
      <li> &lt;config java_options="…"&gt;</li>
      <li> &lt;config java_class_path="…"&gt;</li>
      <li> &lt;config include_path="…"&gt;</li>
    </ul>
    
    
    
    <h2>Protokolldateien</h2>
    
    <p>
      Protokollausgaben werden in die Dateien des lokalen, aufrufenden Job Schedulers geschrieben. 
      Das betrifft sowohl das Auftragsprotokoll als auch das Task-Protokoll.
      Ausgaben nach <code>stdout</code> und <code>stderr</code> werden in die Protokolldateien des lokalen, 
      aufrufenden Job Schedulers übernommen. 
      Andere Protokollausgaben, die der Job Scheduler protokolliert, 
      werden in die Protokolldatei des entfernten Job Schedulers geschrieben.
    </p>
    
    
    
    <h2>Shell Scripte auf einem entfernten Rechner ausführen</h2>
    
    <p>
      Shell Scripte können mit Jobs entfernt ausgeführt werden, 
      wenn die Standard Job-Implementierung <i>sos.scheduler.process.JobSchedulerProcessSubprocessJob</i> 
      verwendet wird (siehe Dokumentation der Klasse). 
      Die von den Shell Scripten produzierten Ausgaben nach <code>stdout</code> und <code>stderr</code> werden im Protoll beim lokalen, 
      aufrufenden Job Scheduler ausgegeben. 
      Ein beim Job angegebener <scheduler_element name="job" attribute="timeout"/> wird nicht ausgewertet, 
      d.h. die Task wird nicht abgebrochen, wenn der als Timeout angegebene Wert erreicht ist.
    </p>
    
</description>
