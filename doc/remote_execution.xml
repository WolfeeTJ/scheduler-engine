<?xml version="1.0" encoding="utf-8"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com) by Andreas Pueschel (APL Software GmbH) -->
<?xml-stylesheet href="scheduler.xsl" type="text/xsl"?>
<!--$Id: job.xml 4950 2007-04-12 06:39:59Z fs $-->

<description	title="Externe Jobverarbeitung" 
							base_dir=""
							author="$Author: fs,ur $"
							date="$Date: 2007-04-20 16:39:59 +0200 (Fr, 20 Apr 2007) $">

		<p>
			API-Jobs können auf einem entfernten Job Scheduler ausgeführt werden. 
		</p>
		
		<p>
			Entfernt ausgeführte Jobs verhalten sich gegenüber den aufrufenden Job Scheduler so wie lokal ausgeführte Jobs. 
			Lediglich die Rechenlast wird auf einen anderen Job Scheduler übertragen.
		</p>
		
		<p>
			Das bedeutet z.B. auch, dass alle API-Aufrufe sich auf das lokale Scheduler-Objekt beziehen.
		</p>
		
		<p>
			Die Log-Ausgaben des Jobs, sowie der Endzustand und eventuelle Fehler werden an den 
			aufrufenden Job Scheduler geleitet.
		</p>
		
		
		
		<h2>Verwendung</h2>
		
		<p>
			Überwiegend werden Scheduler mit der Ausführung von Jobs beauftrag, die auf einem anderen physikalischen Rechner installiert sind.<br/><br/>Beispiele für die Verwendung:
			
			<ol>
				<li>
					Das Verfahren dient dem Lastausgleich.
				</li>
				<li>
					Es können Softwareinstallationen verwendet werden, die sich nicht auf dem lokalen Rechner befinden.
				</li>
				<li>
					Es können Hardwarekomponenten verwendet werden, die nur von einem anderen Rechner erreichbar sind (z.B. Drucker)
				</li>
			</ol>
		</p>
		
		
		
		<h2>Voraussetzungen</h2>
		
		<ol>
			<li>Einstellungen in der Firewall
				<p>
					Der lokale Scheduler muss den entfernten Scheduler erreichen können. 
					Alle Sicherheitseinstellungen in den Firewalls müssen das berücksichtigen. 
					Für die Kommunikation in Richtung entfernter Scheduler muss der Port des entfernten 
					Rechners in der Firewall freigeschaltet sein. 
					In der entgegengesetzten Richtung verbindet sich die Task mit dem aufrufenden Scheduler über 
					einen Port &lt;5999 abwärts zählend pro laufende Task.
					Entsprechend der erwarteten Anzahl Tasks müssen diese Ports in der Firewall freigeschaltet sein.
				</p>
			</li>
			<li>
				Security-Einstellungen in der Scheduler-Konfiguration
				<p>
					Der entfernte Scheduler muss im Security-Tag den aufrufenden Scheduler legitimieren. 
					<br/><br/>
					Beispiel
					<pre>
&lt;security ignore_unknown_hosts="no"&gt;
    &lt;allowed_host host="123.456.89.1" level="all"/&gt;
&lt;/security&gt;
					</pre>
				</p>
			</li>
			<li>
				Beide Job Scheduler müssen gestartet sein.
			</li>
		</ol>
		
		
		
		<h2>Konfiguration</h2>
		
		<p>
			Die Job-Definition steht in der Konfigurationsdatei des lokalen, aufrufenden Job Scheduler.<br/>
			Um einen Job auf einem anderen Job Scheduler ausführen zu lassen, sind beim lokalen, 
			aufrufenden Job Scheduler folgende Konfigurationen nötig:
		</p>
		<p>
			<ul>
				<li>
					Es muss eine Prozessklasse angelegt werden,
					und in ihr das Attribut <scheduler_element name="process_class" attribute="remote_scheduler" value=""/>
					gesetzt sein.
					Dadurch werden alle Jobs, die dieser Prozessklasse zugeordnet sind extern ausgeführt.
					<br/><br/>
					Beispiel
					<pre>
&lt;process_classes&gt;
    &lt;process_class name="remote"
                   max_processes="3"
                   remote_scheduler="remoteHost:4445"/&gt;
&lt;/process_classes&gt;
					</pre>
				</li>
			</ul>
			<ul>
				<li>
					Der Job muss der Prozessklasse zugeordnet werden,<br/>
					siehe <scheduler_element name="job" attribute="process_class"/>
				</li>
			</ul>
		</p>
		
		
		
		<h2>Monitor-Script</h2>
		
		<p>
			Die zu einem Job gehörenden Monitor-Scripte werden ebenfalls am entfernten Job Scheduler ausgeführt. 
			So gibt z.B. dieses Testscript den Rechnernamen des entfernten Rechners aus.
			<pre>
	function spooler_process_before(){
     spooler_log.info("host:tcp_port:" + spooler.tcp_port);
     var  localhost = new java.net.InetAddress.getLocalHost();
     hostname = localhost.getHostName();
     ip = localhost.getHostAddress();
     spooler_log.info("==>" + hostname + ":::"+ ip);
  }
			</pre>
		</p>
		
		
		
		<h2>Kontext der API-Aufrufe</h2>
		
		<p>
			Alle Api-Aufrufe beziehen sich auf den lokalen, aufrufenden Job Scheduler. 
			So liefert z.B. die Methode <pre>spooler.ini_path</pre> den Namen der 
			Datei <i>factory.ini</i> beim lokalen, aufrufenden Job Scheduler und nicht beim entfernten Job Scheduler zurück. 
			Dieser Dateiname steht möglicherweise beim entfernten Dateisystem nicht zur Verfügung. 
			Das Gleiche gilt für die Methode <pre>spooler.directory</pre>, 
			denn die beiden Job Scheduler können unterschiedliche Basisverzeichnisse haben.
		</p>
		
		
		
		<h2>Konfigurations-Dateien></h2>
	
		<p>
			Alle Einstellungen werden beim lokalen, aufrufenden Job Scheduler gelesen.
		</p>
		
		<p>
			Einige Einstellungen werden vom entfernten statt vom lokalen, aufrufenden Scheduler übernommen:
		</p>
		<ul> 
			<li> sos.ini (Abschnitt [java], Eintrag javac=…)</li>
			<li> factory.ini (Abschnitt [spooler], Eintrag tmp=…)</li>
			<li> &lt;config java_options="…"&gt;</li>
			<li> &lt;config java_class_path="…"&gt;</li>
			<li> &lt;config include_path="…"&gt;</li>
		</ul>
		
		
		
		<h2>Protokolldateien</h2>
		
		Protokollausgaben werden in die Dateien des lokalen, aufrufenden Job Schedulers geschrieben. Das betrifft sowohl das Order-Log als auch das Task-Log.
		Ausgaben nach Standard-Out werden in die Protokolldateien des lokalen, aufrufenden Job Schedulers übernommen. 
		Andere Protokollausgaben, die der Scheduler protokolliert, werden in die Protokolldatei des entfernten Schedulers geschrieben.
		

		<h2>Shellscripte auf einem entfernten Rechner ausführen</h2>
		
		<p>
			Shellscripte können mit Jobs entfernt ausgeführt werden, 
			wenn die Standard Job-Implementierung <i>sos.scheduler.process.JobSchedulerProcessSubprocessJob</i> 
			verwendet wird (siehe Dokumentation der Klasse). 
			Die von den Shellscripten produzierten Ausgaben nach Stdout werden im Protoll beim lokalen, 
			aufrufenden Scheduler ausgegeben. 
			Ein beim Job angegebener <scheduler_element name="job" attribute="timeout"/> wird nicht ausgewertet, 
			d.h. die Task wird nicht abgebrochen, wenn der bei Timeout angegebene Wert erreicht ist.
		</p>
</description>
