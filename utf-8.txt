$Id$

SCHEDULER AUF UTF-8 UMSTELLEN


- Weiterhin std::string benutzen

- Alle .cxx-Quellen in UTF-8 umsetzen

- BSTR <--> string
  Alle BSTR aufsuchen, die nicht mit String_from_bstr() konvertiert werden
  Einige werden vielleicht noch in einer Schleife (OLECHAR*)[] = (char*)[] konvertiert
  BSTR kommt an 1000 Programmstellen vor

- BSTR <--> Java
  Java modified UTF-8: \0 -> 0xC0 0x80, Supplementary Characters als zwei mal drei byte lange UTF-8-Folgen (nicht 4 byte UTF-8)

- Dateinamen: Unter Unix Locale benutzen?, unter Windows openw() oder OpenFile()

- Hüllroutine für Unix: system_from_utf8(), wcsrtombs() (Identität bei UTF-8)

- Directory lesen, Dateityp Dir

- Scheduler: Verzeichnisüberwachung

- Scheduler: Windows-Dienste-Schnittstelle

- string_from_file( dateiname, encoding )

- Hostware-Dateien vermeiden

- Hostware-Log: openw() verwenden
  Am besten aus der Hostware rausnehmen und von iostream() befreien

- Außer Dateitypen odbc und jdbc: 
  SQL-Strings in UTF-8, werden aber vom Dateityp in Datenbank-Zeichencodierung umgesetzt
  
- Ebenso Clob-Zugriff

- ODBC und JDBC: set_parameter()

- Dateiinhalt in UTF-8 oder einstellbar: <include encoding="utf-8">

- Protokolldateien immer in UTF-8

- HTTP-Schnittstelle: HTML in UTF-8

- Kommandozeile GetCommandLineW(), CommandLineToArgvW()?, Unix und argv: Locale verwenden

- 3rd_party: regex (kann jetzt nur 7bit)

- 3rd_party: libxml-Dateizugriff (DTD und vielleicht Schema)

- libxml2, libxslt: Keine Konvertierung zu ISO-8859-1 mehr

- Hostole: File.get() sollte auch in Unicode erfolgen, oder nicht?
  Vielleicht: file.open( "-encoding=iso-8859-1 ..." )
  
- Einige Aufrufe von fwrite(), fprintf(stderr). 
  Zum Beispiel für die Antwort von scheduler -send-cmd=".."
  
- Von der Hostware entkoppeln. 
  Nur für Datenbanken hostole einsetzen
  Hostole mit put_binary(), get_binary(), Binary_from_file()
  
- Any_file um UTF-8-Methoden erweitern: Any_file.get_line(), .put_line().  
  get() und put() bleiben binär.

- [hostole] coding_scheme=old, falls eine Anwendung inkompatibel ist?

- Strings sortieren (wo verwenden wir das?), 
  std::map<string,T> --> std::map<wstring,T> ?, ebenso set<>
  
- wchar_t unter Gnu hat 32bit , ebenso vermutlich wstring.
  wchar_t unter Windows hat 16bit, umfasst also nicht die Supplementary Characters
  
- Zu UTF-8 unter Gnu: http://www.cl.cam.ac.uk/~mgk25/unicode.html

- Implementierung von wcwidth(): http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
  
- Gnu: Im Hauptprogram Locale nach der Umgebung setzen: setlocale(LC_TYPE,""). Default ist sonst "C".
  printf("%ls", L"Schöne Grüße") gibt den String dann korrekt codiert aus
  (dazu muss aber der Compiler den String korrekt erkennen: er muss die Codierung der Quelle kennen).
  
- Gnu: wcsrtombs() codiert ins eingestellte Locale,
  iconv_open() etc. (gibt's das auf für Windows?)
  
- utf8_mode = (strcmp(nl_langinfo(CODESET), "UTF-8") == 0)  
  
- Perl: 5.8.1 verwenden (in 5.8.0 soll Unicode fehlerhaft implementiert sein)

- Wenn Hostware UTF-8 verarbeitet (Any_file), dann hostodbc ebenso

- stdout und stderr der Tasks, Subprozesse und <process> entsprechend dem Locale decodieren
  Ebenso subprocess.stdout, .stderr
