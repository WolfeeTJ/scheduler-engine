// *** Generated by com.sos.scheduler.engine.cplusplus.generator ***

#include "spooler.h"
#include "../zschimmer/java.h"
#include "../zschimmer/Has_proxy.h"
#include "../zschimmer/javaproxy.h"
#include "../zschimmer/lazy.h"

using namespace ::zschimmer;
using namespace ::zschimmer::javabridge;

namespace zschimmer { namespace javabridge { 

    template<> const class_factory<Proxy_class> has_proxy< ::sos::scheduler::http::Chunk_reader >::proxy_class_factory("com.sos.scheduler.engine.kernel.cppproxy.HttpChunkReaderCImpl");

}}

namespace javaproxy { namespace com { namespace sos { namespace scheduler { namespace engine { namespace kernel { namespace cppproxy { 

static jstring JNICALL content_1type(JNIEnv* jenv, jobject, jlong cppReference)
{
    Env env = jenv;
    try {
        ::sos::scheduler::http::Chunk_reader* o_ = has_proxy< ::sos::scheduler::http::Chunk_reader >::of_cpp_reference(cppReference,"::sos::scheduler::http::Chunk_reader::content_type()");
        return env.jstring_from_string(o_->content_type());
    }
    catch(const exception& x) {
        env.set_java_exception(x);
        return jstring();
    }
}

}}}}}}}

namespace javaproxy { namespace com { namespace sos { namespace scheduler { namespace engine { namespace kernel { namespace cppproxy { 

static jint JNICALL get_1next_1chunk_1size(JNIEnv* jenv, jobject, jlong cppReference)
{
    Env env = jenv;
    try {
        ::sos::scheduler::http::Chunk_reader* o_ = has_proxy< ::sos::scheduler::http::Chunk_reader >::of_cpp_reference(cppReference,"::sos::scheduler::http::Chunk_reader::get_next_chunk_size()");
        return (o_->get_next_chunk_size());
    }
    catch(const exception& x) {
        env.set_java_exception(x);
        return jint();
    }
}

}}}}}}}

namespace javaproxy { namespace com { namespace sos { namespace scheduler { namespace engine { namespace kernel { namespace cppproxy { 

static jboolean JNICALL next_1chunk_1is_1ready(JNIEnv* jenv, jobject, jlong cppReference)
{
    Env env = jenv;
    try {
        ::sos::scheduler::http::Chunk_reader* o_ = has_proxy< ::sos::scheduler::http::Chunk_reader >::of_cpp_reference(cppReference,"::sos::scheduler::http::Chunk_reader::next_chunk_is_ready()");
        return (o_->next_chunk_is_ready());
    }
    catch(const exception& x) {
        env.set_java_exception(x);
        return jboolean();
    }
}

}}}}}}}

namespace javaproxy { namespace com { namespace sos { namespace scheduler { namespace engine { namespace kernel { namespace cppproxy { 

static jobject JNICALL read_1from_1chunk__I(JNIEnv* jenv, jobject, jlong cppReference, jint p0)
{
    Env env = jenv;
    try {
        ::sos::scheduler::http::Chunk_reader* o_ = has_proxy< ::sos::scheduler::http::Chunk_reader >::of_cpp_reference(cppReference,"::sos::scheduler::http::Chunk_reader::read_from_chunk()");
        return java_byte_array_from_c(o_->read_from_chunk(p0));
    }
    catch(const exception& x) {
        env.set_java_exception(x);
        return jobject();
    }
}

}}}}}}}

const static JNINativeMethod native_methods[] = {
    { (char*)"content_type__native", (char*)"(J)Ljava/lang/String;", (void*)::javaproxy::com::sos::scheduler::engine::kernel::cppproxy::content_1type },
    { (char*)"get_next_chunk_size__native", (char*)"(J)I", (void*)::javaproxy::com::sos::scheduler::engine::kernel::cppproxy::get_1next_1chunk_1size },
    { (char*)"next_chunk_is_ready__native", (char*)"(J)Z", (void*)::javaproxy::com::sos::scheduler::engine::kernel::cppproxy::next_1chunk_1is_1ready },
    { (char*)"read_from_chunk__native", (char*)"(JI)[B", (void*)::javaproxy::com::sos::scheduler::engine::kernel::cppproxy::read_1from_1chunk__I }
};

namespace zschimmer { namespace javabridge { 

    template<> void has_proxy< ::sos::scheduler::http::Chunk_reader >::register_cpp_proxy_class_in_java() {
        Env env;
        Class* cls = has_proxy< ::sos::scheduler::http::Chunk_reader >::proxy_class_factory.clas();
        int ret = env->RegisterNatives(*cls, native_methods, 4);
        if (ret < 0)  env.throw_java("RegisterNatives");
    }

}}
