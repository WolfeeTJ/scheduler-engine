<?xml version="1.0" encoding="iso-8859-1"?><xsl:stylesheet 	xmlns:xsl = "http://www.w3.org/1999/XSL/Transform" 	xmlns:fn="urn:http://www.w3.org/2005/02/xpath-functions"	version="2.0">	<xsl:output method="xml" omit-xml-declaration="no" version="1.0" doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN" indent="yes" encoding="ISO-8859-1" />  <xsl:preserve-space elements="*"/>  <xsl:param name="P_CONFIGURATION" /><xsl:param name="P_SCHEDULER_ROOT" select="'c:/scheduler/scheduler.src.release/prod'" /><xsl:param name="P_VC_INSTALL_DIR" select="'C:/Program Files/Microsoft Visual Studio 9.0/VC'" /><xsl:param name="P_JAVA_HOME" select="'C:/Programme/Java/jdk1.6.0_18'" /><xsl:variable name="JAVA_HOME" select="replace($P_JAVA_HOME,'\\','/')" /><xsl:variable name="OPTIONS" select="document(options.xml)/CompilerOptions" /><xsl:variable name="CONFIGURATION" select="concat($P_CONFIGURATION,'|Win32')" /><xsl:variable name="CONFIGURATION_LOW" select="lower-case($P_CONFIGURATION)" /><xsl:variable name="DEFAULT_INCLUDES" select="concat($P_VC_INSTALL_DIR,'/include;',$P_VC_INSTALL_DIR,'/../../Microsoft SDKs/Windows/v6.0A/Include')" /><xsl:template match="/">		<project name="com.sos.scheduler.compile.{$CONFIGURATION_LOW}" basedir=".">   <property name="scheduler.src" value="{$P_SCHEDULER_ROOT}" />   <target      name="compile.msvc.env"      description="Environment für C++ setzen"   >      <exec executable="vcvars32.bat" dir="{$P_VC_INSTALL_DIR}/bin" />   </target>	<xsl:apply-templates />		</project>	</xsl:template><xsl:template match="projects">	<xsl:apply-templates /></xsl:template><xsl:template match="project">	<xsl:variable name="depends">		<xsl:call-template name="join">			<xsl:with-param name="nodeList" select="dependencies/dependency" />			<xsl:with-param name="delimiter" select="','" />			<xsl:with-param name="prefix" select="'compile.'" />			<xsl:with-param name="suffix" select="concat('.',$CONFIGURATION_LOW)" />		</xsl:call-template>	</xsl:variable>	<xsl:variable name="docname" select="concat($P_SCHEDULER_ROOT,'/',translate(@location,'\','/'))" />	<xsl:message><xsl:value-of select="concat('... performing document ',$docname)" /></xsl:message>	<xsl:variable name="project" select="document($docname)" />	<xsl:apply-templates select="$project/VisualStudioProject">		<xsl:with-param name="project" select="@name" />		<xsl:with-param name="projectpath" select="@path" />		<xsl:with-param name="depends" select="$depends" />	</xsl:apply-templates></xsl:template><xsl:template match="VisualStudioProject"><xsl:param name="project" /><xsl:param name="projectpath" /><xsl:param name="depends" />		<xsl:variable name="all_depends">		<xsl:choose>			<xsl:when test="$depends!=''">				<xsl:value-of select="concat('compile.msvc.env,',$depends)" />			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="'compile.msvc.env'" />			</xsl:otherwise>		</xsl:choose>	</xsl:variable>	   <target		name="compile.{$project}.{$CONFIGURATION_LOW}"   	depends="{$all_depends}"		description="compile {$project} (configuration is {$CONFIGURATION_LOW})"   >      	<xsl:variable name="projectfullpath" select="replace(concat($P_SCHEDULER_ROOT,'/',$projectpath),'\\','/')" />   	   	<!-- precompiled header -->   	<xsl:if test="Files/File/FileConfiguration[@Name=$CONFIGURATION]/Tool[@Name='VCCLCompilerTool']/@UsePrecompiledHeader='1'">		  	<exec executable="cl.exe" dir="{$projectfullpath}">		  			  		<!-- Die Argumente (arg-Elemente) werden zunächst in einem internen Baum gesammelt ... -->		  		<xsl:variable name="result">					<xsl:apply-templates select="Files/File/FileConfiguration[@Name=$CONFIGURATION]">						<xsl:with-param name="alternateset" select="Configurations/Configuration[@Name=$CONFIGURATION]" />						<xsl:with-param name="pch" select="'create'" />					</xsl:apply-templates>					<xsl:apply-templates select="Configurations/Configuration[@Name=$CONFIGURATION]">						<xsl:with-param name="pch" select="'create'" />					</xsl:apply-templates>		  		</xsl:variable>		  				  		<!-- Doppelt vorhandenen Argumente nur 1x ausgeben -->		  		<xsl:variable name="output">			  		<xsl:for-each select="$result/arg">			  			<xsl:if test="not(@value=following-sibling::arg/@value)">				  			<xsl:copy-of select="." />			  			</xsl:if>			  		</xsl:for-each>		  		</xsl:variable>		  		<arg line="{string-join($output/arg/@value,' ')}" />		  						<xsl:apply-templates select="Files/File"/>		  				  		<xsl:choose>					<xsl:when test="$result/env/@key!='INCLUDE'">						<env key="INCLUDE" path="{$DEFAULT_INCLUDES}" />					</xsl:when>					<xsl:otherwise>						<xsl:variable name="path" select="replace($result/env/@path,'\.\\',concat($projectfullpath,'/'))" />						<env key="INCLUDE">							<xsl:attribute name="path">								<xsl:value-of select="concat( $path,';',$DEFAULT_INCLUDES)" />							</xsl:attribute>						</env>					</xsl:otherwise>				</xsl:choose>			</exec>	</xsl:if>		  	<exec executable="cl.exe" dir="{$P_SCHEDULER_ROOT}/{$projectpath}">  		<xsl:variable name="result2">			<xsl:apply-templates select="Configurations/Configuration[@Name=$CONFIGURATION]" />		</xsl:variable>		  		  		<!-- Doppelt vorhandenen Argumente nur 1x ausgeben -->  		<xsl:variable name="output2">	  		<xsl:for-each select="$result2/arg">	  			<xsl:if test="not(@value=following-sibling::arg/@value)">		  			<xsl:copy-of select="." />	  			</xsl:if>	  		</xsl:for-each>  		</xsl:variable>  		<arg line="{string-join($output2/arg/@value,' ')}" />				<xsl:apply-templates select="Files/Filter[@Name='Source Files']/File"/>		<xsl:apply-templates select="Files/Filter[@Name='Quellcodedateien']/File"/>		  		  		<xsl:choose>			<xsl:when test="$result2/env/@key!='INCLUDE'">				<env key="INCLUDE" path="{$DEFAULT_INCLUDES}" />			</xsl:when>			<xsl:otherwise>				<xsl:variable name="path" select="replace($result2/env/@path,'\.\\',concat($projectfullpath,'/'))" />				<env key="INCLUDE">					<xsl:attribute name="path">						<xsl:value-of select="concat($path,';',$DEFAULT_INCLUDES)" />					</xsl:attribute>				</env>			</xsl:otherwise>		</xsl:choose>			</exec>			</target></xsl:template><xsl:template match="Configuration|FileConfiguration"><xsl:param name="alternateset" select="dummy/node" /><xsl:param name="pch" select="'use'" />	<arg value="/c" />		<xsl:variable name="defaultfile" select="replace(replace(@InheritedPropertySheets,'\\','/'),'\$\(VCInstallDir\)',concat($P_VC_INSTALL_DIR,'/'))" />			<xsl:apply-templates select="document($defaultfile)/VisualStudioPropertySheet/Tool">			<xsl:with-param name="alternateset" select="$alternateset" />			<xsl:with-param name="pch" select="$pch" />		</xsl:apply-templates>			<!-- Zeichensatz - @CharacterSet -->		<xsl:if test="normalize-space(@CharacterSet)!=''">			<xsl:choose>				<xsl:when test="@CharacterSet=1">					<arg value="/D &quot;_UNICODE&quot;" /> 					<arg value="'/D &quot;UNICODE&quot;'" /> 				</xsl:when>				<xsl:when test="@CharacterSet=2">					<arg value="/D &quot;_MBCS&quot;" /> 				</xsl:when>			</xsl:choose>		</xsl:if>			<xsl:apply-templates>			<xsl:with-param name="alternateset" select="$alternateset" />			<xsl:with-param name="pch" select="$pch" />		</xsl:apply-templates></xsl:template><xsl:template match="Tool[@Name='VCCLCompilerTool']"><xsl:param name="alternateset" /><xsl:param name="pch" select="'use'" />	<!--	=========================================================================================================	Allgemein	=========================================================================================================	-->		<!-- Zus_liche Includeverzeichnisse - @AdditionalIncludeDirectories -->	<xsl:if test="normalize-space(@AdditionalIncludeDirectories )!=''">		<xsl:call-template name="outputTokens">			<xsl:with-param name="key" select="'AdditionalIncludeDirectories'" />			<xsl:with-param name="list" select="@AdditionalIncludeDirectories" />			<xsl:with-param name="delimiter" select="';'" />			<xsl:with-param name="prefix" select="'/I &quot;'" />			<xsl:with-param name="suffix" select="'&quot;'" />		</xsl:call-template>		<xsl:variable name="path" select="replace(@AdditionalIncludeDirectories,'\$\(JAVA_HOME\)',$JAVA_HOME)" />	   <env key="INCLUDE" path="{$path}" />	</xsl:if>	<!-- #using Verweise aufl_ - @AdditionalUsingDirectories -->	<xsl:if test="normalize-space(@AdditionalUsingDirectories)!=''">		<xsl:call-template name="outputTokens">			<xsl:with-param name="key" select="'AdditionalUsingDirectories'" />			<xsl:with-param name="list" select="@AdditionalUsingDirectories" />			<xsl:with-param name="delimiter" select="';'" />			<xsl:with-param name="prefix" select="'/AI &quot;'" />			<xsl:with-param name="suffix" select="'&quot;'" />		</xsl:call-template>	</xsl:if>	<!-- Debuginformationsformat - @DebugInformationFormat-->	<xsl:if test="normalize-space(@DebugInformationFormat)!='' and @DebugInformationFormat!=0">		<xsl:choose>			<xsl:when test="@DebugInformationFormat=1">				<arg value="/Z7" />			</xsl:when>			<xsl:when test="@DebugInformationFormat=3">				<arg value="/Zi" />			</xsl:when>			<xsl:when test="@DebugInformationFormat=4">				<arg value="/ZI" />			</xsl:when>		</xsl:choose>	</xsl:if>	<!-- Startbanner unterdr_ppressStartupBanner-->	<xsl:if test="@SuppressStartupBanner='true'">		<arg value="/nologo" />	</xsl:if>	<!-- Warnstufe - @WarningLevel-->	<xsl:if test="normalize-space(@WarningLevel)!=''">		<arg>			<xsl:attribute name="value">				<xsl:value-of select="concat('/W',@WarningLevel)" />			</xsl:attribute>		</arg>	</xsl:if>	<!-- Nach 64bit Portabilit__blemen suchen - @Detect64BitPortabilityProblems -->	<xsl:if test="@Detect64BitPortabilityProblems='true'">		<arg value="/Wp64" />	</xsl:if>	<!-- Warnungen als Fehler behandeln - @WarnAsError -->	<xsl:if test="@WarnAsError='true'">		<arg value="/WX" />	</xsl:if>	<!-- UNICODE Antwortdateien verwenden - @UseUnicodeResponseFiles -->	<!-- keine Auswirkung ? -->	<!--	=========================================================================================================	Optimierung	=========================================================================================================	-->		<!-- Optimierung - @Optimization -->	<xsl:if test="normalize-space(@Optimization)!='' and @Optimization!=4">		<xsl:choose>			<xsl:when test="@Optimization=0">				<arg value="/Od" />			</xsl:when>			<xsl:when test="@Optimization=1">				<arg value="/Ob1" />			</xsl:when>			<xsl:when test="@Optimization=2">				<arg value="/O2" />			</xsl:when>			<xsl:when test="@Optimization=3">				<arg value="/Ox" />			</xsl:when>		</xsl:choose>	</xsl:if>		<!-- Inlinefunktionserweiterung - @InlineFunctionExpansion-->	<xsl:if test="normalize-space(@InlineFunctionExpansion)!='' and @InlineFunctionExpansion!=0">		<xsl:choose>			<xsl:when test="@InlineFunctionExpansion=1">				<arg value="/Ob1" />			</xsl:when>			<xsl:when test="@InlineFunctionExpansion=2">				<arg value="/Ob2" />			</xsl:when>		</xsl:choose>	</xsl:if>		<!-- Systeminterne Funktionen aktivieren - @EnableIntrinsicFunctions -->	<xsl:if test="@EnableIntrinsicFunctions='true'">		<arg value="/Oi" />	</xsl:if>		<!-- Größe oder Geschwindigkeit bevorzugen - @FavorSizeOrSpeed -->	<xsl:if test="normalize-space(@FavorSizeOrSpeed)!='' and @FavorSizeOrSpeed!=0">		<xsl:choose>			<xsl:when test="@FavorSizeOrSpeed=1">				<arg value="/Ot" />			</xsl:when>			<xsl:when test="@FavorSizeOrSpeed=2">				<arg value="/Os" />			</xsl:when>		</xsl:choose>	</xsl:if>		<!-- Framezeiger unterdr_itFramePointers-->	<xsl:if test="@OmitFramePointers='true'">		<arg value="/Oy" />	</xsl:if>	<!-- Fiber-sichere Optimierung aktivieren - @EnableFiberSafeOptimizations -->	<xsl:if test="@EnableFiberSafeOptimizations ='true'">		<arg value="/GT" />	</xsl:if>		<!-- Komplette Programmoptimierung - @WholeProgramOptimization -->	<xsl:if test="@WholeProgramOptimization ='true'">		<arg value="/GL" />	</xsl:if>		<!--	=========================================================================================================	Präprozessor	=========================================================================================================	-->		<!-- Preprozessordefinitionen - @PreprocessorDefinitions -->	<xsl:if test="normalize-space(@PreprocessorDefinitions)!=''">		<xsl:call-template name="outputTokens">			<xsl:with-param name="key" select="'PreprocessorDefinitions'" />			<xsl:with-param name="list" select="@PreprocessorDefinitions" />			<xsl:with-param name="delimiter" select="';'" />			<xsl:with-param name="prefix" select="'/D &quot;'" />			<xsl:with-param name="suffix" select="'&quot;'" />		</xsl:call-template>	</xsl:if>		<!-- Standardincludepfad ignorieren - @IgnoreStandardIncludePath-->	<xsl:if test="@IgnoreStandardIncludePath='true'">		<arg value="/X" /> 	</xsl:if>	<!-- Pr__ssorlauf - @GeneratePreprocessedFile-->	<xsl:if test="normalize-space(@GeneratePreprocessedFile)!='' and @GeneratePreprocessedFile!=0">		<arg value="/P" /> 		<xsl:if test="@GeneratePreprocessedFile=2">			<arg value="/EP" /> 		</xsl:if>	</xsl:if>	<!-- Kommentare beibehalten - @KeepComments-->	<xsl:if test="@KeepComments='true'">		<arg value="/C" /> 	</xsl:if>	<!--	=========================================================================================================	Codegenerierung	=========================================================================================================	-->		<!-- Stringpooling aktivieren - @StringPooling -->	<xsl:if test="@StringPooling ='true'">		<arg value="/GF" /> 	</xsl:if>		<!-- Minimale Neuerstellung aktivieren - @MinimalRebuild -->	<xsl:if test="@MinimalRebuild ='true'">		<arg value="/Gm" /> 	</xsl:if>		<!-- C++-Ausnahmen aktivieren - @ExceptionHandling (default EHsc) -->	<xsl:choose>		<xsl:when test="@ExceptionHandling=2">			<arg value="/EHa" /> 		</xsl:when>		<xsl:otherwise>			<arg value="/EHsc" /> 		</xsl:otherwise>	</xsl:choose>		<!-- Überprüfen von kleineren Typen - @SmallerTypeCheck -->	<xsl:if test="@SmallerTypeCheck ='true'">		<arg value="/RTCc" /> 	</xsl:if>		<!-- Vollst_ige Laufzeit__n - @BasicRuntimeChecks -->	<xsl:if test="normalize-space(@BasicRuntimeChecks )!='' and @BasicRuntimeChecks !=0">		<xsl:choose>			<xsl:when test="@BasicRuntimeChecks=1">				<arg value="/RTCs" /> 			</xsl:when>			<xsl:when test="@BasicRuntimeChecks=2">				<arg value="/RTCu" /> 			</xsl:when>			<xsl:when test="@BasicRuntimeChecks=3">				<arg value="/RTC1" /> 			</xsl:when>		</xsl:choose>	</xsl:if>		<!-- Laufzeitblibliothek - @RuntimeLibrary (default MTd) -->	<xsl:choose>		<xsl:when test="@RuntimeLibrary=0">			<arg value="/MT" /> 		</xsl:when>		<xsl:when test="@RuntimeLibrary=1">			<arg value="/MTd" /> 		</xsl:when>		<xsl:when test="@RuntimeLibrary=2">			<arg value="/MD" /> 		</xsl:when>		<xsl:when test="@RuntimeLibrary=3">			<arg value="/MDd" /> 		</xsl:when>	</xsl:choose>	<!-- Ausrichten der Strukturmember - @StructMemberAlignment -->	<xsl:if test="normalize-space(@StructMemberAlignment )!='' and @StructMemberAlignment!=0">		<xsl:choose>			<xsl:when test="@StructMemberAlignment=1">				<arg value="/Zp1" /> 			</xsl:when>			<xsl:when test="@StructMemberAlignment=2">				<arg value="/Zp2" /> 			</xsl:when>			<xsl:when test="@StructMemberAlignment=3">				<arg value="/Zp4" /> 			</xsl:when>			<xsl:when test="@StructMemberAlignment=4">				<arg value="/Zp8" /> 			</xsl:when>			<xsl:when test="@StructMemberAlignment=5">				<arg value="/Zp16" /> 			</xsl:when>		</xsl:choose>	</xsl:if>		<!-- Puffer Sicherheit_ufferSecurityCheck -->	<xsl:if test="@BufferSecurityCheck ='false'">		<arg value="/GS-" /> 	</xsl:if>	<!-- Funktionslevel linking aktivieren - @EnableFunctionLevelLinking -->	<xsl:if test="@EnableFunctionLevelLinking ='true'">		<arg value="/Gy" /> 	</xsl:if>	<!-- Erweitertes Anweisungsset aktivieren - @EnableEnhancedInstructionSet -->	<xsl:if test="normalize-space(@EnableEnhancedInstructionSet )!='' and @EnableEnhancedInstructionSet !=0">		<xsl:choose>			<xsl:when test="@EnableEnhancedInstructionSet =1">				<arg value="/arch:SSE" /> 			</xsl:when>			<xsl:when test="@EnableEnhancedInstructionSet =2">				<arg value="/arch:SSE2" /> 			</xsl:when>		</xsl:choose>	</xsl:if>	<!-- Gleitkommamodell - @FloatingPointModel -->	<xsl:if test="normalize-space(@FloatingPointModel )!='' and @FloatingPointModel !=0">		<xsl:choose>			<xsl:when test="@EnableEnhancedInstructionSet =1">				<arg value="/fp:strict" /> 			</xsl:when>			<xsl:when test="@EnableEnhancedInstructionSet =2">				<arg value="/fp:fast" /> 			</xsl:when>		</xsl:choose>	</xsl:if>	<!-- Gleitkommaausnahmen aktivieren - @FloatingPointExceptions -->	<xsl:if test="@FloatingPointExceptions ='true'">		<arg value="/fp:except" /> 	</xsl:if>	<!--	=========================================================================================================	Sprache	=========================================================================================================	-->		<!-- Spracherweiterungen deaktivieren - @DisableLanguageExtensions-->	<xsl:if test="@DisableLanguageExtensions='true'">		<arg value="/Za" /> 	</xsl:if>	<!-- Standardzeichen 'unsigned' - @DefaultCharIsUnsigned -->	<xsl:if test="@DefaultCharIsUnsigned ='true'">		<arg value="/J" /> 	</xsl:if>	<!-- wchar_t als integrierten Typ behandeln - @TreatWChar_tAsBuiltInType -->	<xsl:if test="@TreatWChar_tAsBuiltInType='false'">		<arg value="/Zc:wchar_t-" /> 	</xsl:if>	<!-- Übereinstimmung in einem For-Schleifenbereich erzwingen - @ForceConformanceInForLoopScope -->	<xsl:if test="@ForceConformanceInForLoopScope='false'">		<arg value="/Zc:forScope" /> 	</xsl:if>	<!-- Laufzeittypinfo aktivieren - @RuntimeTypeInfo -->	<xsl:if test="@RuntimeTypeInfo='false'">		<arg value="/GR-" /> 	</xsl:if>	<!-- Open MP Unterst_penMP -->	<xsl:if test="@OpenMP='false'">		<arg value="/openmp" /> 	</xsl:if>	<!--	=========================================================================================================	Vorkompilierte Header	=========================================================================================================	-->	<!-- Vorkompilierten Header erstellen/verwenden - @UsePrecompiledHeader/@PrecompiledHeaderThrough -->	<xsl:if test="normalize-space(@UsePrecompiledHeader)!='' and @UsePrecompiledHeader!=0">		<xsl:variable name="file">			<xsl:choose>				<xsl:when test="normalize-space(@PrecompiledHeaderThrough)!=''">					<xsl:value-of select="@PrecompiledHeaderThrough" />				</xsl:when>				<xsl:when test="normalize-space($alternateset/Tool/@PrecompiledHeaderThrough)!=''">					<xsl:value-of select="$alternateset/Tool/@PrecompiledHeaderThrough" />				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="'StdAfx.h'" />				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:choose>			<xsl:when test="@UsePrecompiledHeader=1 and $pch = 'create'">				<arg>					<xsl:attribute name="value">						<xsl:value-of select="concat('/Yc&quot;',$file,'&quot;')" />					</xsl:attribute>				</arg>			</xsl:when>			<xsl:when test="@UsePrecompiledHeader=2 and $pch = 'use'">				<arg>					<xsl:attribute name="value">						<xsl:value-of select="concat('/Yu&quot;',$file,'&quot;')" />					</xsl:attribute>				</arg>			</xsl:when>		</xsl:choose>	</xsl:if>		<!-- Vorkompilierte  Headerdatei - @PrecompiledHeaderFile -->	<xsl:choose>		<xsl:when test="normalize-space(@PrecompiledHeaderFile)!=''">			<arg>				<xsl:attribute name="value">					<xsl:value-of select="concat('/Fp&quot;',@PrecompiledHeaderFile,'&quot;')" />				</xsl:attribute>			</arg>		</xsl:when>		<xsl:when test="normalize-space($alternateset/Tool/@PrecompiledHeaderFile)!=''">			<arg>				<xsl:attribute name="value">					<xsl:value-of select="concat('/Fp&quot;',$alternateset/Tool/@PrecompiledHeaderFile,'&quot;')" />				</xsl:attribute>			</arg>		</xsl:when>	</xsl:choose>	<!--	=========================================================================================================	Ausgabedateien	=========================================================================================================	-->	<!-- Quelle mit Attributen erweitern - @ExpandAttributedSource -->	<xsl:if test="@ExpandAttributedSource='true'">		<xsl:element name="arg">			<xsl:attribute name="value">				<xsl:value-of select="'/Fx'" />			</xsl:attribute>		</xsl:element>		</xsl:if>	<!-- Assemblyausgabe - @AssemblerOutput -->	<xsl:if test="normalize-space(@AssemblerOutput)!='' and @AssemblerOutput !=0">		<xsl:element name="arg">			<xsl:attribute name="value">					<xsl:choose>						<xsl:when test="@AssemblerOutput=1">							<xsl:value-of select="'/FA'" />						</xsl:when>						<xsl:when test="@AssemblerOutput=2">							<xsl:value-of select="'/FAcs'" />						</xsl:when>						<xsl:when test="@AssemblerOutput=3">							<xsl:value-of select="'/FAc'" />						</xsl:when>						<xsl:when test="@AssemblerOutput=4">							<xsl:value-of select="'/FAs'" />						</xsl:when>					</xsl:choose>			</xsl:attribute>		</xsl:element>		</xsl:if>	<!-- ASM Listenspeicherort - @AssemblerListingLocation -->	<xsl:if test="normalize-space(@AssemblerOutput)!='' and @AssemblerOutput!=0 and normalize-space(@AssemblerListingLocation)!=''">		<xsl:variable name="path" select="replace(@AssemblerListingLocation,'\$\(IntDir\)',replace(../@IntermediateDirectory,'\\','/') )" />		<xsl:element name="arg">			<xsl:attribute name="value">				<xsl:value-of select="concat('/Fa&quot;',$path,'&quot;')" />			</xsl:attribute>		</xsl:element>		</xsl:if>	<!-- Objektdateiname - @ObjectFile -->	<xsl:if test="normalize-space(@ObjectFile)!=''">		<xsl:variable name="path" select="replace(@ObjectFile,'\$\(IntDir\)', replace(../@IntermediateDirectory,'\\','/') )" />		<xsl:element name="arg">			<xsl:attribute name="value">				<xsl:value-of select="concat('/Fo&quot;',$path,'&quot;')" />			</xsl:attribute>		</xsl:element>		</xsl:if>	<!-- Programmdatenbankdateiname - @ProgramDataBaseFileName -->	<xsl:if test="normalize-space(@ProgramDataBaseFileName)!=''">		<xsl:variable name="path" select="replace(@ProgramDataBaseFileName,'\$\(IntDir\)', replace(../@IntermediateDirectory,'\\','/') )" />		<xsl:element name="arg">			<xsl:attribute name="value">				<xsl:value-of select="concat('/Fd&quot;',$path,'&quot;')" />			</xsl:attribute>		</xsl:element>		</xsl:if>	<!-- XML Dokumentationsdatei generieren - @GenerateXMLDocumentationFiles -->	<!-- Name der XML Dokumentationsdatei - @XMLDocumentationFileName -->	<xsl:if test="@GenerateXMLDocumentationFiles = 'true' and normalize-space(@XMLDocumentationFileName)!=''">		<xsl:variable name="path" select="replace(@XMLDocumentationFileName,'\$\(IntDir\)', replace(../@IntermediateDirectory,'\\','/') )" />		<xsl:element name="arg">			<xsl:attribute name="value">				<xsl:value-of select="concat('/doc &quot;',$path,'&quot;')" />			</xsl:attribute>		</xsl:element>		</xsl:if>	<!--	=========================================================================================================	Informationen durchsuchen	=========================================================================================================	-->	<!-- Browserinformationen aktivieren - @BrowseInformation -->	<!-- Browserdateidatei - @BrowseInformationFile -->	<xsl:if test="normalize-space(@BrowseInformation)!='' and @BrowseInformation!=0 and normalize-space(@BrowseInformationFile)!=''">		<xsl:variable name="path" select="replace(@BrowseInformationFile,'\$\(IntDir\)', replace(../@IntermediateDirectory,'\\','/') )" />		<xsl:element name="arg">			<xsl:attribute name="value">					<xsl:choose>						<xsl:when test="@BrowseInformation=1">							<xsl:value-of select="concat('/FR &quot;',$path,'&quot;')" />						</xsl:when>						<xsl:when test="@BrowseInformation=2">							<xsl:value-of select="concat('/Fr &quot;',$path,'&quot;')" />						</xsl:when>					</xsl:choose>			</xsl:attribute>		</xsl:element>		</xsl:if>	<!--	=========================================================================================================	Erweitert	=========================================================================================================	-->		<!-- Aufrufkonvention - @CallingConvention -->		<!-- Kompilierungsart - @CompileAs -->	<xsl:element name="arg">		<xsl:attribute name="value">			<xsl:choose>				<xsl:when test="@CompileAs = '1'">					<xsl:value-of select="'/TC'" />				</xsl:when>				<xsl:when test="@CompileAs = '2'">					<xsl:value-of select="'/TP'" />				</xsl:when>			</xsl:choose>		</xsl:attribute>	</xsl:element>		<!-- Bestimmte Warnungen deaktivieren - @DisableSpecificWarnings -->		<!-- Includes erzwingen - @ForcedIncludeFiles -->		<!-- #using erzwingen - @ForcedUsingFiles -->		<!-- Includes anzeigen - @ShowIncludes -->		<!-- Pr_ozessordefinition aufheben - @UndefinePreprocessorDefinitions -->		<!-- Vollst_ige Pfade verwenden - @UseFullPaths -->		<!-- Standardbibliotheksnamen unterdr_itDefaultLibName -->		<!-- Problembericht - @ErrorReporting -->	<xsl:element name="arg">		<xsl:attribute name="value">				<xsl:choose>					<xsl:when test="@ErrorReporting =2">						<xsl:value-of select="'/errorReport:queue'" />					</xsl:when>					<xsl:otherwise>						<xsl:value-of select="'/errorReport:prompt'" />					</xsl:otherwise>				</xsl:choose>		</xsl:attribute>	</xsl:element>			</xsl:template><!--<xsl:template match="Files">	<xsl:apply-templates select="Filter[@Name='Source Files']" /></xsl:template><xsl:template match="Filter">	<xsl:apply-templates /></xsl:template>--><xsl:template match="File">	<xsl:element name="arg">		<xsl:attribute name="value">			<xsl:value-of select="@RelativePath" />		</xsl:attribute>	</xsl:element></xsl:template><xsl:template match="text()|@*|*"></xsl:template><xsl:template name="outputTokens"><xsl:param name="key"/><xsl:param name="list"/><xsl:param name="delimiter"/><xsl:param name="prefix" select="''"/><xsl:param name="suffix" select="''"/>	<xsl:variable name="newlist">		<xsl:choose>			<xsl:when test="contains($list, $delimiter)">				<xsl:value-of select="normalize-space($list)"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="concat(normalize-space($list), $delimiter)"/>			</xsl:otherwise>		</xsl:choose>	</xsl:variable>	<xsl:variable name="first" select="substring-before($newlist, $delimiter)"/>	<xsl:variable name="remaining" select="substring-after($newlist, $delimiter)"/>		<xsl:variable name="content" select="replace($first,'\$\(JAVA_HOME\)',$JAVA_HOME)" />		<arg>		<xsl:attribute name="value">			<xsl:value-of select="concat($prefix,$content,$suffix)" />		</xsl:attribute>	</arg>	<xsl:if test="$remaining">		<xsl:call-template name="outputTokens">			<xsl:with-param name="key" select="$key" />			<xsl:with-param name="list" select="$remaining"/>			<xsl:with-param name="delimiter" select="$delimiter" />			<xsl:with-param name="prefix" select="$prefix"/>			<xsl:with-param name="suffix" select="$suffix"/>		</xsl:call-template>	</xsl:if></xsl:template><xsl:template name="join">  <xsl:param name="nodeList"/>  <xsl:param name="delimiter"/>  <xsl:param name="prefix" select="''"/>  <xsl:param name="suffix" select="''"/>  <xsl:for-each select="$nodeList">  		<xsl:if test="position()!=1"><xsl:value-of select="$delimiter" /></xsl:if>  		<xsl:value-of select="concat($prefix,@name,$suffix)"/>  </xsl:for-each></xsl:template></xsl:stylesheet>