// hostole.odl                          (C)1997 SOS GmbH Berlin
// $Id$

// §1735


[
    uuid        ( 9F716A00-D1F0-11CF-869D-444553540000 ),
    helpstring  ( "hostWare (hostOLE), SOS GmbH, Berlin" ),
    lcid        ( 0x0000 ),
    version     ( 1.1 )
]
library hostWare
{
    #ifdef WIN32
        importlib("STDOLE32.TLB");
    #else
        importlib("STDOLE.TLB");
    #endif

    import "../zschimmer/java.odl";
    #include "hostole_odl.h"

    interface Ihostware_record_type;
    interface Ihostware_field_descr;
    interface Ihostware_field_type;
    interface Ivariables_enumerator;
    interface Ivariables2_idispatch_enumerator;


    //typedef
    enum Script_item_flags              // Codierung aus activscp.h (Microsoft)
    {
        sif_isvisible      = 0x0002,
        sif_issource       = 0x0004,
        sif_globalmembers  = 0x0008,
        sif_ispersistent   = 0x0010,
        sif_nocode         = 0x0400,
        sif_codeonly       = 0x0200,
    };


    //typedef
    enum Scripttext_flags
    {
        scripttext_isvisible    = 0x00000002,
        scripttext_isexpression = 0x00000020,
        scripttext_ispersistent = 0x00000040
    };

    //-----------------------------------------------------------------------------------IException
    /*
    [
        uuid       ( 9F716A11-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Iexception : IDispatch
    {
        [propget]
        HRESULT                 Name                        ( [out,retval] BSTR* code );

        [propget]
        HRESULT                 code                        ( [out,retval] BSTR* code );

        [propget]
        HRESULT                 text                        ( [out,retval] BSTR* text );
    }

    [
        uuid       ( 9F716A12-D1F0-11CF-869D-444553540000 )
    ]
    coclass Exception
    {
        interface Iexception;
    }
    */
    //------------------------------------------------------------------------------Ivariable

    [
        uuid       ( 9F716A20-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Ivariable : IDispatch
    {
        [id(0),propput]
        HRESULT                 Value                       ( [in,optional] VARIANT* index, [in] VARIANT* Value );

        [id(0),propget]
        HRESULT                 Value                       ( [in,optional] VARIANT* index, [out,retval] VARIANT* Value );

        [id(1)]
        HRESULT                 Dim                         ( [in] int size );

        [id(2),propget]
        HRESULT                 Name                        ( [out,retval] BSTR* Name );

      //[id(-5),propput]
      //HRESULT                 evaluate                    ( [in,optional] VARIANT* index, [in] VARIANT* Value );

      //[id(-5),propget]
      //HRESULT                 evaluate                    ( [in,optional] VARIANT* index, [out,retval] VARIANT* Value );
    }

    [
        uuid       ( 9F716A21-D1F0-11CF-869D-444553540000 )
    ]
    coclass Variable
    {
        interface Ivariable;
      //interface Ivariable2;
    }

    //-----------------------------------------------------------------------------Ivariables

    [
        uuid       ( 9F716A22-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Ivariables : IDispatch
    {
        [id(1)]
        HRESULT                 Set_var                     ( [in] BSTR Name, [in] VARIANT* Value );

        [id(0),propput]  // variables("Name")
        HRESULT                 Value                       ( [in] BSTR Name, [in] VARIANT* Value );        

        [id(0),propget]  // variables("Name")
        HRESULT                 Value                       ( [in] BSTR Name, [out,retval] Ivariable** result );

        [id(2),propget]
        HRESULT                 Count                       ( [out,retval] int* Value );

        [id(3)]
        HRESULT                 Clone                       ( [out,retval] Ivariables** result );

      //[id(DISPID_NEWENUM),propget,restricted]
        [id(DISPID_NEWENUM),propget]
        HRESULT                 _NewEnum                    ( [out,retval] IUnknown** Enumerator );    

        [id(4),propput]
        HRESULT                 Xml                         ( [in] BSTR xml_text );

        [id(4),propget]
        HRESULT                 Xml                         ( [out,retval] BSTR* result );

        [id(5)]
        HRESULT                 Obj_enumerator              ( [out,retval] Ivariables2_idispatch_enumerator** Enumerator );     // Für Delphi, 4.6.04
    }

    [
        uuid       ( 9F716A23-D1F0-11CF-869D-444553540000 )
    ]
    coclass Variables
    {
        interface Ivariables;
      //interface Ivariables2;
    }

    //----------------------------------------------------------Hostware_variables_enumerator

    [
        uuid       ( 9F716A24-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Ivariables_enumerator : IEnumVARIANT
    { 
        HRESULT                 Next                    ( [in] unsigned long celt, [out] VARIANT* rgvar, [out,retval] unsigned long* pceltFetched );
        HRESULT                 Skip                    ( [in] unsigned long celt );
        HRESULT                 Reset                   ();
      //HRESULT                 Clone                   ( Ivariables_enumerator** ppenum );
    }

    [
        uuid       ( 9F716A25-D1F0-11CF-869D-444553540000 )
    ]
    coclass Variables_enumerator
    {
        interface Ivariables_enumerator;
    }

    //----------------------------------------------------------Ivariables_idispatch_enumerator
/*
    [
        uuid       ( 9F716A24-D1F0-11CF-869D-444553540001 ),
        odl,
        dual
    ]
    interface Ivariables_idispatch_enumerator : IDispatch
    { 
        HRESULT                 Next                    ( [out,retval] Ivariable** result );        // Für Delphi/IDispatch
    }

    [
        uuid       ( 9F716A25-D1F0-11CF-869D-444553540001 )
    ]
    coclass Variables_idispatch_enumerator
    {
        interface Ivariables_idispatch_enumerator;
    }
*/    
    //-----------------------------------------------------------------------------Ivariable2

    [
        uuid       ( 9F716A26-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Ivariable2 : IDispatch
    {
        // Namen sollen mit Unterstrich beginnen, damit sie nicht mit Variablennamen verwechselt werden.

        [id(0),propput]
        HRESULT                 Obj_value                   ( [in,optional] VARIANT* index, [in] VARIANT* Value );

        [id(0),propget]
        HRESULT                 Obj_value                   ( [in,optional] VARIANT* index, [out,retval] VARIANT* Value );

        [id(1)]
        HRESULT                 Obj_dim                     ( [in] int size );

        [id(2),propget]
        HRESULT                 Obj_name                    ( [out,retval] BSTR* Name );

      //[id(-5),propput]
      //HRESULT                 Evaluate                    ( [in,optional] VARIANT* index, [in] VARIANT* Value );

      //[id(-5),propget]
      //HRESULT                 Evaluate                    ( [in,optional] VARIANT* index, [out,retval] VARIANT* Value );
    }

    [
        uuid       ( 9F716A27-D1F0-11CF-869D-444553540000 )
    ]
    coclass Variable2
    {
        interface Ivariable2;
    }

    //-----------------------------------------------------------------------------Ivariables2

    [
        uuid       ( 9F716A28-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Ivariables2 : IDispatch
    {
        // Namen sollen mit "Obj_" beginnen, damit sie nicht mit Variablennamen verwechselt werden.

        [id(0),propput]  // variables("Name")
        HRESULT                 Obj_value                   ( [in] BSTR Name, [in] VARIANT* Value );        

        [id(0),propget]  // variables("Name")
        HRESULT                 Obj_value                   ( [in] BSTR Name, [out,retval] VARIANT* result );

      //[id(1)]
      //HRESULT                 _Set_var                    ( [in] BSTR Name, [in] VARIANT* Value );

        [id(2),propget,helpstring("true, wenn die Variablenmenge leer ist")]
        HRESULT                 Obj_is_empty                ( [out,retval] VARIANT_BOOL* Value );

        [id(3)]
        HRESULT                 Obj_clone                   ( [out,retval] Ivariables2** result );

      //[id(DISPID_NEWENUM),propget,restricted]
        [id(DISPID_NEWENUM),propget]
        HRESULT                 _NewEnum                    ( [out,retval] IUnknown** Enumerator );    

        [id(4),propput]
        HRESULT                 Obj_xml                     ( [in] BSTR xml_text );

        [id(4),propget]
        HRESULT                 Obj_xml                     ( [out,retval] BSTR* result );
      
      //[id(5)]
      //HRESULT                 _Merge                      ( [in] Ivariables* to_add, [in] VARIANT_BOOL overwrite );

        [id(5)]
        HRESULT                 Obj_enumerator              ( [out,retval] Ivariables2_idispatch_enumerator** Enumerator );     // Für Delphi, 4.6.04
    }

    [
        uuid       ( 9F716A29-D1F0-11CF-869D-444553540000 )
    ]
    coclass Variables2
    {
        interface Ivariables2;
    }

    //----------------------------------------------------------Hostware_variables2_enumerator

    [
        uuid       ( 9F716A30-D1F0-11CF-869D-444553540000 ),
        odl,
        dual
    ]
    interface Ivariables2_enumerator : IEnumVARIANT
    { 
        [helpstring("Liefert die nächste Variable")]
        HRESULT                 Next                    ( [in] unsigned long celt, [out] VARIANT* rgvar, [out,retval] unsigned long* pceltFetched );

        [helpstring("Überspring die nächsten n Variablen")]
        HRESULT                 Skip                    ( [in] unsigned long celt );

        [helpstring("Setzt den Enumerator auf die erste Variable zurück")]
        HRESULT                 Reset                   ();

        //HRESULT                 Clone                   ( Ivariables2_enumerator** ppenum );

      //HRESULT                 Get_next                ( [out,retval] IDispatch** result );        // Für Delphi/IDispatch
    }

    [
        uuid       ( 9F716A31-D1F0-11CF-869D-444553540000 )
    ]
    coclass Variables2_enumerator
    {
        interface Ivariables2_enumerator;
    }

    //----------------------------------------------------------Ivariables2_idispatch_enumerator

    [
        uuid       ( 9F716A24-D1F0-11CF-869D-444553540002 ),
        odl,
        dual
    ]
    interface Ivariables2_idispatch_enumerator : IDispatch  // Für Delphi/IDispatch
    { 
        [helpstring("Liefert die nächste Variable")]
        HRESULT                 Next                    ( [out,retval] Ivariable2** result );

        [propget,helpstring("true, wenn es eine nächste Variable gibt")]
        HRESULT                 Has_next                ( [out,retval] VARIANT_BOOL* result );        // Für Delphi/IDispatch
    }

    [
        uuid       ( 9F716A25-D1F0-11CF-869D-444553540002 )
    ]
    coclass Variables2_idispatch_enumerator
    {
        interface Ivariables2_idispatch_enumerator;
    }
    
    //--------------------------------------------------------------------------Hostware_dynobj

    [
        uuid       ( 9F716A02-D1F0-11CF-869D-444553540000 ),
      //             9F716A80-D1F0-11CF-869D-444553540000    für Implementierung Hostware_dynobj, s. hostole.cxx
        helpstring ( "Definition of interface Ihostware_dynobj" ),
        odl,
        dual
    ]
    interface Ihostware_dynobj : IDispatch
    {
      //[id(-5)]
      //HRESULT                 Obj_evaluate                ( [out,retval] VARIANT* result );

        [id(1)]
        HRESULT                 Obj_add_field               ( [in] BSTR Name, [in] VARIANT* Type );  // BSTR oder Ihostware_type

        [id(2),propget,helpstring("Die Anzahl der Felder des Records")]
        HRESULT                 Obj_field_count             ( [out,retval] int* field_count );

        [id(3),propget]
        HRESULT                 Obj_field_name              ( [in] int field_no, [out,retval] BSTR* Name );

        [id(4),propput]
        HRESULT                 Obj_write_empty_as_null     ( [in] VARIANT_BOOL b );

        [id(5),propget]
        HRESULT                 Obj_field_index             ( [in] BSTR Name, [out,retval] int* field_no );

        [id(6),helpstring( "Liefert Kopie des Datensatzes" )]
        HRESULT                 Clone                       ( [out,retval] Ihostware_dynobj** record );

        [id(7)]
        HRESULT                 Obj_field                   ( [in] VARIANT* Name, [out,retval] VARIANT* Value );

        [id(8)]
        HRESULT                 Obj_set_field               ( [in] VARIANT* Name, [in] VARIANT* Value );

        [id(9),propget]
        HRESULT                 Obj_xml                     ( [in,defaultvalue("")] BSTR options, [out,retval] BSTR* result );

        [id(9),propput]
        HRESULT                 Obj_xml                     ( [in,defaultvalue("")] BSTR options, [in] BSTR Xml );

        [id(10),propget]
        HRESULT                 Obj_type                    ( [out,retval] Ihostware_record_type** );

        [id(11),propget]
        HRESULT                 Java_class_name             ( [out,retval] BSTR* result );          // Damit java_class_name über IDispatch, statt über Ihas_java_class_name gerufen werden kann

        [id(12),propput]
        HRESULT                 Obj_read_null_as_empty      ( [in] VARIANT_BOOL b );
    }

    [
        uuid       ( 9F716A06-D1F0-11CF-869D-444553540000 ),
        helpstring ( "hostWare dynamic data object" )
    ]
    coclass Dyn_obj
    {
        interface Ihostware_dynobj;
        interface Ihas_java_class_name;
    }

    //------------------------------------------------------------------------Hostware_type_info

    [
        uuid       ( 9F716A0A-D1F0-11CF-869D-444553540000 ),
        odl,
        dual,
        nonextensible
    ]
    interface Ihostware_type_info : IDispatch    // (nicht mit ITypeInfo zu verwechseln)
    {
        [propget] HRESULT Name          ( [out,retval] BSTR* Name );
    }

    [
        uuid( 9F716A0C-D1F0-11CF-869D-444553540000 )
    ]
    coclass Type_info 
    { 
        interface Ihostware_type_info; 
    }

    //-----------------------------------------------------------------------Hostware_type_param

    typedef 
    [ helpstring( "Kategorie des Typs" ) ]
    enum Hostware_std_type
    {
        [helpstring( "Undefinierte Typ-Kategorien" )]
        hwst_none = 0,

        [helpstring( "Zeichenkette fester Länge, Leerzeichen am Ende werden ignoriert")]
        hwst_char = 1,

        [helpstring( "Zeichenkette variabler Länge")]
        hwst_varchar = 2,

        [helpstring( "Dezimalzahl")]
        hwst_decimal = 3,

        [helpstring( "Ganze Zahl")]
        hwst_integer = 4,

        [helpstring( "Fließkommazahl")]
        hwst_float = 5,

        [helpstring( "Datum")]
        hwst_date = 6, 

        [helpstring( "Zeit" ) ]
        hwst_time = 7, 
          
        [helpstring( "Datum und Zeit" ) ]
        hwst_date_time = 8,

        [helpstring( "Boolean (Ja/Nein)" ) ]
        hwst_bool = 9
    } 
    Hostware_std_type;


    [
        uuid       ( 9F716A0B-D1F0-11CF-869D-444553540000 ),
        odl,
        dual,
        nonextensible  // Invoke() kennt nur hier deklarierte Methoden
    ]
    interface Ihostware_type_param : IDispatch
    {
        [propget] HRESULT Std_type      ( [out,retval] Hostware_std_type* o );
        [propget] HRESULT Size          ( [out,retval] long* o );
        [propget] HRESULT Display_size  ( [out,retval] long* o );
        [propget] HRESULT Precision     ( [out,retval] long* o );
        [propget] HRESULT Radix         ( [out,retval] long* o );
        [propget] HRESULT Scale         ( [out,retval] VARIANT* o );     // long oder NULL
        [propget] HRESULT Usigned       ( [out,retval] VARIANT_BOOL* o );
        [propget] HRESULT Info          ( [out,retval] Ihostware_type_info** o );
    }

    [
        uuid( 9F716A0D-D1F0-11CF-869D-444553540000 )
    ]
    coclass Type_param
    { 
        interface Ihostware_type_param; 
    }

    //----------------------------------------------------------------------Hostware_field_type

    [
        uuid       ( 9F716A09-D1F0-11CF-869D-444553540000 ),
        odl,
        dual,
        nonextensible
    ]
    interface Ihostware_field_type : IDispatch
    {
        [propget] HRESULT Field_size    ( [out,retval] long* o );
        [propget] HRESULT Info          ( [out,retval] Ihostware_type_info** o );
        [propget] HRESULT Param         ( [out,retval] Ihostware_type_param** o );
    }

    [
        uuid( 9F716A10-D1F0-11CF-869D-444553540000 )
    ]
    coclass Field_type
    { 
        interface Ihostware_field_type; 
    }

    //---------------------------------------------------------------------Hostware_record_type

    [
        uuid       ( 9F716A07-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Definition of interface Irecord_type" ),
        odl,
        dual,
        nonextensible  // Invoke() kennt nur hier deklarierte Methoden
    ]
    interface Ihostware_record_type : Ihostware_field_type
    {
        [propget, helpstring( "Name des Typs" )]   
        HRESULT Name( [out,retval] BSTR* Name );

        [propget, helpstring( "Anzahl der Felder" )]
        HRESULT Field_count( [out,retval] long* number );

        [propget,helpstring( "Feld" )]               // Collection?
        HRESULT Field_descr( [in] long i, [out,retval] Ihostware_field_descr** o );

        [helpstring( "Feld hinzufügen" )]
        HRESULT Add_field_descr( [in] Ihostware_field_descr* o );

        [helpstring( "Feld hinzufügen" )]
        HRESULT Add_field( [in] BSTR Name, [in] BSTR Type );

        [propget] 
        HRESULT Param( [out,retval] Ihostware_type_param** o );
    }

    [
        uuid( 9F716A0E-D1F0-11CF-869D-444553540000 )
    ]
    coclass Record_type
    { 
        interface Ihostware_record_type;
    }

    //---------------------------------------------------------------------Hostware_field_descr

    [
        uuid       ( 9F716A08-D1F0-11CF-869D-444553540000 ),
        odl,
        dual,
        nonextensible
    ]
    interface Ihostware_field_descr : IDispatch
    {
        [propget, helpstring( "Name des Feldes" )]   
        HRESULT Name( [out,retval] BSTR* Name );

        [propget]
        HRESULT Type( [out,retval] Ihostware_field_type** Type );

        [propget, helpstring( "Position im Datensatz (ab 0)" )]
        HRESULT Offset( [out,retval] long* o );

        [propget, helpstring( "Kommentar" )]
        HRESULT Remark( [out,retval] BSTR* o );
    }

    [
        uuid( 9F716A0F-D1F0-11CF-869D-444553540000 )
    ]
    coclass Field_descr
    { 
        interface Ihostware_field_descr;
    }

    //----------------------------------------------------------------------------Hostware_file
    
    [
        uuid       ( 9F716A01-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Definition of interface Ihostware_file" ),
        odl,
        dual,
        nonextensible
    ]
    interface Ihostware_file : IDispatch
    {
        [id(1),helpstring( "Open a file" )]
        HRESULT Open( [in] BSTR Filename );

        [id(2),helpstring( "Close the file" )]
        HRESULT Close( void );

        [id(3),helpstring( "Close the file" )]
        HRESULT Close_file( void );            // "close" ist in Visual Basic reserviert

        [id(4),helpstring( "get next text record" )]
        HRESULT Get_line( [out,retval] BSTR* buffer );

        [id(5),helpstring( "append a text record" )]
        HRESULT Put_line( [in] BSTR record );

        [id(6),helpstring( "create a blank object" )]
        HRESULT Create_record( [out,retval] Ihostware_dynobj** record );

        [id(7),helpstring( "create a blank key object" )]
        HRESULT Create_key( [out,retval] Ihostware_dynobj** key );

        [id(8),helpstring( "get next record as an object (functional)" )]
        HRESULT Get( [out,retval] Ihostware_dynobj** object );

        [id(9),helpstring( "append object to the file" )]
        HRESULT Put( [in] VARIANT* object );

        [id(10),helpstring( "position direct by key" )]
        HRESULT Set_key( [in] VARIANT* key );

        [id(11),helpstring( "delete record by key" )]
        HRESULT Delete_key( [in] VARIANT* key );

        [id(12),helpstring( "get directly record by key" )]
        HRESULT Get_key( [in] VARIANT* key, [out,retval] Ihostware_dynobj** object );

        [id(13),helpstring( "insert object" )]
        HRESULT Insert( [in] VARIANT* record );

        [id(14),helpstring( "write back object" )]
        HRESULT Update( [in] VARIANT* record );

        [id(15),helpstring( "update directly record" )]
        HRESULT Update_direct( [in] VARIANT* record );

        [id(16),helpstring( "update directly or insert record" )]
        HRESULT Store( [in] VARIANT* record );

        [id(17),helpstring( "end of file?" )]
        HRESULT Eof( [out,retval] VARIANT_BOOL* eof );

        [id(18),propput, helpstring( "set date format" )]
        HRESULT Date_format( [in] BSTR format );

        [id(19),propput, helpstring( "set decimal symbol" )]
        HRESULT Decimal_symbol( [in] BSTR decimal_symbol );

        [id(20),propget, helpstring( "Feldname" )]   // Besser: Type liefert Record_type mit Field_descr (mit ODBC-Methoden precision() etc.)
        HRESULT Field_name( [in] long number, [retval,out] BSTR* Name );

        [id(21),propget, helpstring( "Feldanzahl" )] 
        HRESULT Field_count( [retval,out] long* number );

        [id(22),helpstring( "Prepare statement" )]
        HRESULT Prepare( [in] BSTR Filename );

        [id(23),propput]
        HRESULT Parameter( [in] long no, [in] VARIANT* Value );

        [id(24),helpstring( "execute prepared statement" )]
        HRESULT Execute();

        [id(25),propput, helpstring( "Parameterwerte für SQL übergeben" )]
        HRESULT Parameters( [in] SAFEARRAY(VARIANT) param_array );

        [id(26),propget]
        HRESULT Type( [out,retval] Ihostware_record_type** Type );

        [id(27),propget]
        HRESULT Opened( [out,retval] VARIANT_BOOL* result );

        [id(28)]
        HRESULT Rewind();

        [id(29),propput, helpstring( "set date_time format" )]
        HRESULT Date_time_format( [in] BSTR format );

        [id(0),propget,helpstring( "Zeigt Debug-Information an. Für VB5." )]
        HRESULT Debug_info( [out,retval] BSTR* text );

        [id(30),propput]
        HRESULT Write_empty_as_null( [in] VARIANT_BOOL b );

        [id(31),helpstring( "Close the cursor" )]
        HRESULT Close_cursor( void );

        [id(32),propget]
        HRESULT Row_count( [out,retval] int* result );

      //[propget]
      //HRESULT write_empty_as_null( [out,retval] VARIANT_BOOL* b );

        [id(33),propget]
        HRESULT                 Java_class_name             ( [out,retval] BSTR* result );          // Damit java_class_name über IDispatch, statt über Ihas_java_class_name gerufen werden kann
                                                                                                    // Für den Objectserver
        [id(34),propput]
        HRESULT Read_null_as_empty( [in] VARIANT_BOOL b );

        [id(35),vararg,helpstring("Die Datei ist eine geöffnete Dateibank. db_open() liefert eine geöffnete Select-Menge")]
        HRESULT Db_open( [in] BSTR select_statement, [in] SAFEARRAY(VARIANT) param_array, [out,retval] Ihostware_file** result );

        [id(36),vararg,helpstring( "Den ersten Datensatz lesen. SQL-Parameter können angegeben werden." )] 
        HRESULT Db_get_single( [in] BSTR Filename, [in] SAFEARRAY(VARIANT) param_array, [retval,out] Ihostware_dynobj** record );

        [id(37),vararg,helpstring( "Anweisung mit Parametern ausführen" )]
        HRESULT Db_execute( [in] BSTR statement, [in] SAFEARRAY(VARIANT) param_array, [out,retval] int* row_count );

        [id(38),vararg,helpstring( "Ein Feld des ersten Datensatzes lesen. SQL-Parameter können angegeben werden." )] 
        HRESULT Db_get_single_value( [in] BSTR select_statement, [in] SAFEARRAY(VARIANT) param_array, [retval,out] VARIANT* record );

        [id(39),propget]
        HRESULT Filename( [out,retval] BSTR* Filename );

        [id(40),vararg] 
        HRESULT Db_get_blob( [in] BSTR Table_name, [in] BSTR Field_name, [in] BSTR Where_clause, SAFEARRAY(VARIANT) param_array, [retval,out] VARIANT* result );

        [id(41),vararg] 
        HRESULT Db_get_clob( [in] BSTR Table_name, [in] BSTR Field_name, [in] BSTR Where_clause, SAFEARRAY(VARIANT) param_array, [retval,out] VARIANT* result );

        [id(42),vararg,helpstring("Die Datei ist eine geöffnete Dateibank. db_get_array() liefert alle Datensätze als Array")]
        HRESULT Db_get_array( [in] BSTR select_statement, [in] SAFEARRAY(VARIANT) param_array, [out,retval] SAFEARRAY(VARIANT)* result );
    }


    [
        uuid       ( 9F716A03-D1F0-11CF-869D-444553540000 ),
        helpstring ( "hostWare file object" )
    ]
    coclass File
    {
        interface Ihostware_file;
        interface Ihas_java_class_name;
    }

    //----------------------------------------------------------------------------Iscript_object

    [
        uuid       ( 9F716A42-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Skript (scripting engine) als Objekt" ),
        odl,
        dual,
        nonextensible
    ]
    interface Iscript_object : IDispatch
    {
        // Die Werte für id() sind so gewählt, dass sie wahrscheinlich nicht von der Scripting Engine verwendet werden.

        [id(SCRIPT_OBJECT_DISPID+0),helpstring("Sollte bei Verwendung von obj_add_obj() gerufen werden")]
        HRESULT Obj_close();

        [id(SCRIPT_OBJECT_DISPID+1),propput,helpstring("Legt die verwendete Sprache fest, z.B. VBScript, JScript, PerlScript")]
        HRESULT Obj_language( [in] BSTR scripting_engine_name );

        [id(SCRIPT_OBJECT_DISPID+1),propget]
        HRESULT Obj_language( [out,retval] BSTR* scripting_engine_name );

        [id(SCRIPT_OBJECT_DISPID+3),helpstring("Quelltext")]
        HRESULT Obj_parse( [in] BSTR Script_text, [in,defaultvalue(scripttext_isvisible)] enum Scripttext_flags, [out,retval] VARIANT* result );

        [id(SCRIPT_OBJECT_DISPID+4),helpstring("Berechnung eines Ausdrucks")]
        HRESULT Obj_eval( [in] BSTR Script_text, [in,defaultvalue(0)] enum Scripttext_flags, [out,retval] VARIANT* result );

        [id(SCRIPT_OBJECT_DISPID+5),helpstring("Ist der Name (einer Sub oder Variablen) definiert?")]
        HRESULT Obj_name_exists( [in] BSTR sub_name, [out,retval] VARIANT_BOOL* );

        [id(SCRIPT_OBJECT_DISPID+2)]
        HRESULT Obj_add_object( [in] IDispatch* object, [in] BSTR Name, [in,defaultvalue(sif_isvisible)] enum Script_item_flags flags );

        [id(SCRIPT_OBJECT_DISPID+6),helpstring("Quelltext")]
        HRESULT Obj_parse_only( [in] BSTR Script_text, [in,defaultvalue(scripttext_isvisible)] enum Scripttext_flags );

        [id(SCRIPT_OBJECT_DISPID+7)]
        HRESULT Obj_add_variables( Ivariables2* );
    }

    [
        uuid       ( 9F716A43-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Skript als Objekt" )
    ]
    coclass Script_object
    {
        [default] interface Iscript_object;
    }

    //---------------------------------------------------------------------------------Hostware

    [
        uuid       ( 9F716A04-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Definition of interface Ihostware" ),
        odl,
        dual,
        nonextensible
    ]
    interface Ihostware : IDispatch
    {
        [helpstring( "copy file" )]
        HRESULT Copy_file( [in] BSTR source_file, [in] BSTR dest_file );

        [helpstring( "Shell-Kommando ausführen und auf das Ende warten" )]
        HRESULT Shell_execute_and_wait( [in] BSTR file, [in] BSTR verb, [in] double seconds );   // seconds < 0: Keine Zeitbeschränkung

        [vararg,helpstring( "Den ersten Datensatz lesen. SQL-Parameter können angegeben werden." )] 
        HRESULT Get_single( [in] BSTR Filename, [in] SAFEARRAY(VARIANT) param_array, [retval,out] Ihostware_dynobj** record );

        [vararg,helpstring( "Anweisung mit Parametern ausführen" )]
        HRESULT Execute_direct( [in] BSTR statement, [in] SAFEARRAY(VARIANT) param_array );

        [helpstring( "Provisorium" )]                   // Soll eine eigene Klasse werden, evtl. in eigener .dll
        HRESULT Letter_factory( [in] BSTR parameter );

        HRESULT Null( [in] VARIANT* o, [retval,out] VARIANT_BOOL* result );

        HRESULT Empty( [in] VARIANT* o, [retval,out] VARIANT_BOOL* result );

        HRESULT Sleep( [in] double* seconds );

        HRESULT Remove_file( [in] BSTR Filename );

        HRESULT Rename_file( [in] BSTR old_filename, [in] BSTR new_filename );

        HRESULT File_as_string( [in] BSTR Filename, [out,retval] BSTR* string );

        HRESULT As_parser_string( [in] BSTR o, [in] BSTR quote, [out,retval] BSTR* result );  // Baut einen von Hostware_parser erkennbaren String zusammen

        [helpstring("Liefert einfachen Wert als #PCDATA oder Dyn_obj als Folge von Tags")]
        HRESULT As_xml( [in] VARIANT* field_or_dynobj, [in,defaultvalue("")] BSTR options, [out,retval] BSTR* result );

        HRESULT As_date( [in] BSTR date, [in,defaultvalue("")] BSTR format, [out,retval] DATE* result );

        HRESULT Date_as_string( [in] VARIANT* date, [in,defaultvalue("")] BSTR format, [out,retval] BSTR* result );

        [vararg,helpstring( "Alle Datensätze als Array lesen. SQL-Parameter können angegeben werden." )] 
        HRESULT Get_array( [in] BSTR Filename, [in] SAFEARRAY(VARIANT) param_array, [retval,out] SAFEARRAY(VARIANT)* result );

        [helpstring("Liefert #PCDATA als String")]
        HRESULT From_xml( [in] BSTR xml_string, [in,defaultvalue("")] BSTR options, [out,retval] BSTR* result );

        [helpstring("Legt ein Objekt an, deren Klasse durch ein Skript bestimmt ist.")]
        HRESULT Create_object( [in] BSTR script_text_or_class_name, [in,defaultvalue("")] BSTR Language, [out,retval] IDispatch** );

        [helpstring("Liefert einen String in Apostrophen zur Anwendung in einer SQL-Anweisung")]
        HRESULT Sql_quoted( [in] VARIANT Value, [out,retval] BSTR* result );

      //[helpstring("Liefert field_name IS NULL, field_name='value', field_name=value, field_name=%date(value) oder field_name=%timestamp(value), je nach Typ von value")]
        [helpstring("Liefert field_name IS NULL oder field_name='value', je nach Typ von value")]
        HRESULT Sql_equal( [in] BSTR field_name, [in] VARIANT Value, [out,retval] BSTR* expr_string );

        [helpstring("Prüft, ob eine Datei des Dateisystems vorhanden ist.")]
        HRESULT File_exists( [in] BSTR hostware_filename, [out,retval] VARIANT_BOOL* result );

        [helpstring("Legt einen Pfad an. Kein Fehler, wenn Pfad bereits existiert. '..' kann nicht verwendet werden.")]
        HRESULT Make_path( [in] BSTR path );

        [helpstring("Aufruf von GhostScript")]
        HRESULT Ghostscript( [in] BSTR parameters );

        [helpstring("Liefert Anfang und Ende einer Datei")]
        HRESULT Read_begin_and_end_of_file( [in] BSTR Filename, [in] int begin_bytes, [in] int end_bytes, [out,retval] SAFEARRAY(VARIANT)* result );

        [helpstring("Liefert MT940-Datensatz als XML-Dokument (DOM)")]
        HRESULT Parse_mt940( [in] BSTR source_text, [in,defaultvalue("")] BSTR options, [out,retval] IDispatch** dom_document );

        [hidden]
        HRESULT Check_licence( [in] BSTR product_name );

        HRESULT Convert_to( [in] BSTR type_name, [in] VARIANT* Value, [in,defaultvalue("")] BSTR format_not_used, [retval,out] VARIANT* result );

        [helpstring( "Open a file" )]
        HRESULT Open( [in] BSTR Filename, [out,retval] Ihostware_file** file );

        [helpstring( "Verzeichnis mit Dateien und Unterverzeichnissen löschen" )]
        HRESULT Remove_directory( [in] BSTR path, [in,defaultvalue(0)] VARIANT_BOOL force );

        [helpstring( "Stellt einen höheren zu verwendenden Versionsstand der Hostware ein. Z.B. \"1.3.35\"." )]
        HRESULT Use_version( [in] BSTR Version );

        [propget]
        HRESULT Used_version( [out,retval] BSTR* Version );

        [hidden]
        HRESULT Get_log_( [out] void*** ostream, [out] void** system_mutex );

      //[propget]
      //HRESULT exception( [out,retval] Iexception** exception );

      //[propput]
      //HRESULT exception( [in] Iexception* exception );

        [vararg,helpstring( "Ein Feld des ersten Datensatzes lesen. SQL-Parameter können angegeben werden." )] 
        HRESULT Get_single_value( [in] BSTR Filename, [in] SAFEARRAY(VARIANT) param_array, [retval,out] VARIANT* record );

        [helpstring( "Stellt sicher, dass die Hostware wenigstens den angegebenen Versionstand hat." )]
        HRESULT Need_version( [in] BSTR Version );

        [propputref,helpstring("Nicht mehr implementiert"),hidden]
        HRESULT Java_vm__deleted( [in] void* );

        [propget]
        HRESULT Version( [out,retval] BSTR* Version );

        HRESULT Is_version_or_later( [in] BSTR version, [out,retval] VARIANT_BOOL* result );

        [propget]
        HRESULT Log_indent_tls_index( [out,retval] unsigned int* result );

        [helpstring("Liefert hexadezimalen MD5-Wert der 8-Bit-Zeichen (nicht Unicode)")]
        HRESULT Hex_md5_from_bytes( [in] BSTR byte_string, [out,retval] BSTR* result );

        HRESULT                 File_version_info           ( [in] BSTR filename, [in,defaultvalue("")] BSTR option, [out,retval] Ivariables2** result );

        HRESULT                 Chdir                       ( [in] BSTR directory );

        [propget]
        HRESULT                 Java_class_name             ( [out,retval] BSTR* result );          // Damit java_class_name über IDispatch, statt über Ihas_java_class_name gerufen werden kann

        [propget]
        HRESULT                 System_information          ( BSTR what, [in,optional] VARIANT* parameter, [out,retval] VARIANT* );

      //[propput]
      //HRESULT                 Log_context                 ( [in] Log_context** );

        [propget]
        HRESULT                 Log_context                 ( [out,retval] void*** );
    }

    [
        uuid       ( 9F716A05-D1F0-11CF-869D-444553540000 ),
        helpstring ( "hostWare general object" )
    ]
    coclass Global
    {
        interface Ihostware;
        interface Ihas_java_class_name;
    }

    //--------------------------------------------------------------------------------Itoken

    [
        uuid       ( 9F716A17-D1F0-11CF-869D-444553540000 ),
        odl,
        dual,
        nonextensible
    ]
    interface Itoken : IDispatch
    {
        [propget, helpstring("Datei, aus der der Token genommen ist")]
        HRESULT Filename( [out,retval] BSTR* filename );

        [propget, helpstring("Zeilenummer des Tokens")]
        HRESULT Line_no( [out,retval] int* line_number );

        [propget, helpstring("Spaltennummer des Tokens")]
        HRESULT Column_no( [out,retval] int* column_number );

        [propget, helpstring("Kennung des Wortes, wie mit Hostware_parser::add_word zugewiesen")]
        HRESULT Id( [out,retval] int* ident );

      //[propget]
      //HRESULT repr( [out,retval] BSTR* representation );

        [propget, helpstring("Wert des Tokens (Name des Bezeichners, String, Zahl)")]
        HRESULT Value( [out,retval] VARIANT* val );
    }
    [
        uuid       ( 9F716A18-D1F0-11CF-869D-444553540000 ),
    ]
    coclass Token
    {
        [default] interface Itoken;
    }

    //--------------------------------------------------------------------------------Iparser


    [
        uuid       ( 9F716A16-D1F0-11CF-869D-444553540000 ),
        odl,
        dual,
        nonextensible
    ]
    interface Iparser : IDispatch
    {
        [propput, helpstring("Groß-/Kleinschreibung ignorieren")]
        HRESULT Ignore_case( [in] VARIANT_BOOL ignore );

        [propget, helpstring("Groß-/Kleinschreibung ignorieren")]
        HRESULT Ignore_case( [out,retval] VARIANT_BOOL* ignore );

      //[propput]
      //HRESULT source_filename( [in] BSTR filename );

      //[propget]
      //HRESULT source_filename( [out,retval] BSTR* filename );
        
        HRESULT Open_source( [in] BSTR filename );

        HRESULT Add_word( [in] int ident, [in] BSTR representation, [in] VARIANT* extra );
        HRESULT Word_repr( [in] int ident, [out,retval] BSTR* representation );
        HRESULT Word_extra( [in] int ident, [out,retval] VARIANT* extra );

        HRESULT Get_next_token( [out,retval] Itoken** token );
    }

    [
        uuid       ( 9F716A19-D1F0-11CF-869D-444553540000 ),
    ]
    coclass Parser
    {
        [default] interface Iparser;
    }

    //----------------------------------------------------------------------Ifactory_processor
    // Gehört in eine eigene DLL!

    [
        uuid       ( 9F716A41-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Definition of interface IFactoryProcessor" ),
        odl,
        dual,
        nonextensible
    ]
    interface Ifactory_processor : IDispatch
    {
        //HRESULT init();

        [propput,helpstring( "Veraltet für parameter" )]
        HRESULT Param( [in] BSTR parameter );

        [helpstring( "Konvertiert RTF oder Text in ein Skript" )]
        HRESULT Make_script( [in] BSTR rtf_input, [out,retval] BSTR* Script );

        [helpstring( "Lädt und initialisiert die Scripting Engine. Verwenden Sie stattdessen process()!" )]
        HRESULT Init_engine();

        [helpstring( "Entlädt die Scripting Engine. Verwenden Sie stattdessen process()!" )]
        HRESULT Close_engine();

        [propget,helpstring( "Das globale Objekt kann der Scripting Engine mit add_obj hinzugefügt werden" ) ]
        HRESULT Global_object( [out,retval] IDispatch** );

        [helpstring( "Fügt ein Objekt hinzu" )]
        HRESULT Add_obj( [in] IDispatch* obj, [in] BSTR Name, [in,defaultvalue(sif_isvisible)] enum Script_item_flags flags );

        [helpstring( "Übergibt das Skript der Scripting Engine" )]
        HRESULT Parse( [in] BSTR Script, [in,defaultvalue(scripttext_isvisible)] enum Scripttext_flags flags, [out,retval] VARIANT* );

        [helpstring( "Führt das Skript aus. Verwenden Sie stattdessen process()!" )]
        HRESULT Start_engine();

        //HRESULT connect_script();

        [propget,helpstring("Liefert das IActiveScript")]
        HRESULT Script( [out,retval] IUnknown** );  //Besser: IActiveScript, aber wie importiert man das hier? jz 

        [propget,helpstring("Die globalen Variablen und die Prozeduren des Skripts als IDispatch-Schnittstelle")]
        HRESULT Idispatch( [in,defaultvalue("")] BSTR Name, [out,retval] IDispatch** );

        [helpstring("Ist der Name (einer Sub oder Variablen) definiert?")]
        HRESULT Name_exists( [in] BSTR sub_name, [out,retval] VARIANT_BOOL* );

        [helpstring( "Führt #include aus" )]
        HRESULT Preprocess( [in] BSTR Script, [out,retval] BSTR* result_script );

        [propget,helpstring( "Name des fehlerhaften Dokuments" )]
        HRESULT Error_filename( [out,retval] BSTR* filename );

        [propget,helpstring( "Die fehlerhafte Vorlage" )]
        HRESULT Error_document( [out,retval] BSTR* doc );


        // Methoden zur einfacheren Benutzung:

        [propput,helpstring("Skriptsprache, z.B: VBScript, JScript, PerlScript")]
        HRESULT Language( [in] BSTR Language );

        [propget,helpstring("Skriptsprache, z.B: VBScript, JScript, PerlScript")]
        HRESULT Language( [out,retval] BSTR* Language );

        [propput,helpstring("Name der Datei, die die RTF-Vorlage enthält")]
        HRESULT Template_filename( [in] BSTR filename );

        [propget,helpstring("Name der Datei, die die RTF-Vorlage enthält")]
        HRESULT Template_filename( [out,retval] BSTR* filename );

        [propput,helpstring("Name der Datei, die den RTF-Briefbogen enthält")]
        HRESULT Head_filename( [in] BSTR filename );

        [propget,helpstring("Name der Datei, die den RTF-Briefbogen enthält")]
        HRESULT Head_filename( [out,retval] BSTR* filename );

        [propput,helpstring("Name der Datei, die das generierte RTF-Dokument enthalten wird")]
        HRESULT Document_filename( [in] BSTR filename );

        [propget,helpstring("Name der Datei, die das generierte RTF-Dokument enthalten wird")]
        HRESULT Document_filename( [out,retval] BSTR* filename );

        [propputref,helpstring("Setzt die Parameter der Vorlage")]
        HRESULT Parameters( [in] Ivariables* variables );

        [propget,helpstring("Liefert die Parameter der Vorlage")]
        HRESULT Parameters( [out,retval] Ivariables** variables  );

        [propput,helpstring("Setzt einen Parameter für die Vorlage")]
        HRESULT Parameter( [in] BSTR Name, [in] VARIANT* Value );

        [propget,helpstring("Liefert einen Parameter der Vorlage")]
        HRESULT Parameter( [in] BSTR Name, [out,retval] Ivariable** result );

        [helpstring("Verarbeitung: Generieren und Ausführen des Vorlagenskripts")]
        HRESULT Process();


        // Weitere Methoden

        [helpstring("Berechnung eines Ausdrucks")]
        HRESULT Eval( [in] BSTR Script_text, [in,defaultvalue(0)] enum Scripttext_flags, [out,retval] VARIANT* result );

        [helpstring("Sollte am Ende gerufen werden")]
        HRESULT Close();

        [propput,helpstring("Mehrere Aufbereitungen sollen zu einem Dokumente zusammengefasst werden")]
        HRESULT Collect( [in] int count );

        [propget,helpstring("Mehrere Aufbereitungen sollen zu einem Dokumente zusammengefasst werden")]
        HRESULT Collect( [out,retval] int* count );

        [propget,helpstring("Der Dokumentkopf ist (durch einen embed-Baustein) erweitert worden ist.")]
        HRESULT Document_head_modified( [out,retval] VARIANT_BOOL* modified );

        [propget,helpstring("Das gesammelte Dokument ist umkopiert worden, weil der Dokumentkopf (durch einen embed-Baustein) erweitert wurde.")]
        HRESULT Document_copied( [out,retval] VARIANT_BOOL* modified );

        [helpstring("Schließt das zusammengefasste Dokument" )]
        HRESULT Close_output_file();

        [propget,helpstring("Anzahl der bisher zusammengefassten Dokumente (s. collect_documents)." )]
        HRESULT Collected_documents_count( [out,retval] int* count );

        [propget,helpstring( "Verzeichnis für relativen Vorlagendateinamen" )]
        HRESULT Template_dir( [out,retval] BSTR* path );

        [propput,helpstring( "Verzeichnis für relativen Vorlagendateinamen" )]
        HRESULT Template_dir( [in] BSTR path );

        [propget,helpstring( "Verzeichnis des zu erzeugenden Dokuments" )]
        HRESULT Document_dir( [out,retval] BSTR* path );

        [propput,helpstring( "Verzeichnis des zu erzeugenden Dokuments" )]
        HRESULT Document_dir( [in] BSTR path );

        [propget,helpstring( "Name des tatsächlich erzeugten Dokuments (für collect > 0)" )]
        HRESULT Real_document_filename( [out,retval] BSTR* filename );

        [propget,helpstring( "Zuletzt ausgeführte Schritt, für Fehlerlokalisierung: 'make_script', 'template'")]
        HRESULT Last_step( [out,retval] BSTR* step );

        [propget,helpstring( "Konvertiert RTF oder Text in ein Skript" )]
        HRESULT Script_text( [out,retval] BSTR* Script );

        [helpstring( "Übergibt die mit set_parameter() gesetzten Parameter dem Skript. Anschließendes set_parmater() wirkt nicht mehr." )]
        HRESULT Add_parameters();

        [propget,helpstring("false bei collect > 1, wenn das Dokument noch nicht geschrieben ist. Aufzurufen nach process() und template_filename=...")]
        HRESULT Document_written( [out,retval] VARIANT_BOOL* result );

        [propput,helpstring("Für Andreas' Java-Factory")]
        HRESULT Db_name( [in] BSTR Db_name );   // Für Andreas' Java-Factory (§1735)

        [propget,helpstring("Für Andreas' Java-Factory")]
        HRESULT Db_name( [out,retval] BSTR* result ); 

        [propput,helpstring("Verschiedene Vorlagen im selben Ausgabedokument erlauben, close_output_file() schließt Ausgabedokument")]
        HRESULT Merge_documents( [in] VARIANT_BOOL allow );

        [propget,helpstring("Verschiedene Vorlagen im selben Ausgabedokument erlauben, close_output_file() schließt Ausgabedokument")]
        HRESULT Merge_documents( [out,retval] VARIANT_BOOL* result );
    }

    [
        uuid       ( 9F716A40-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Aufbereiter für RTF/VBScript (nur für Document Factory)" )
    ]
    coclass Factory_processor
    {
        [default] interface IFactory_processor;
    }


    //----------------------------------------------------------------------Iseries_factory

    [
        uuid       ( 9F716A45-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Serienaufbereitung" ),
        odl,
        dual,
        nonextensible
    ]
    interface Iseries_factory : IDispatch
    {
        [propget,helpstring( "Name der Datei mit den Aufträgen" )]
        HRESULT Order_filename( [out,retval] BSTR* filename );

        [propput,helpstring( "Name der Datei mit den Aufträgen" )]
        HRESULT Order_filename( [in] BSTR filename );

        [propget,helpstring( "Sprache des Vorlagenskripts" )]
        HRESULT Template_script_language( [out,retval] BSTR* Language );

        [propput,helpstring( "Sprache des Vorlagenskripts" )]
        HRESULT Template_script_language( [in] BSTR Language );

        [propput,helpstring( "Skript, das in jeder Vorlage zuerst ausgeführt wird" )]
        HRESULT Start_script( [in] BSTR Script );

        [propget,helpstring( "Verzeichnis für relative Vorlagendateinamen" )]
        HRESULT Template_dir( [out,retval] BSTR* path );

        [propput,helpstring( "Verzeichnis für relative Vorlagendateinamen" )]
        HRESULT Template_dir( [in] BSTR path );

        [propget,helpstring( "Dateiname der Vorlage" )]
        HRESULT Template_filename( [out,retval] BSTR* filename );
                                                                                                     
        [propput,helpstring( "Dateiname der Vorlage, mit template_dir absolut gemacht" )]
        HRESULT Template_filename( [in] BSTR filename );

        [propput,helpstring("Name der Datei, die den RTF-Briefbogen enthält")]
        HRESULT Head_filename( [in] BSTR filename );

        [propget,helpstring("Name der Datei, die den RTF-Briefbogen enthält")]
        HRESULT Head_filename( [out,retval] BSTR* filename );

        [propget,helpstring( "Verzeichnis der zu erzeugenden Dokumente" )]
        HRESULT Document_dir( [out,retval] BSTR* path );

        [propput,helpstring( "Verzeichnis der zu erzeugenden Dokumente" )]
        HRESULT Document_dir( [in] BSTR path );

        [propput,helpstring( "'#' im Dateinamen werden durch die laufende Nummer ersetzt" )]
        HRESULT Document_filename( [in] BSTR filename );

        [propget,helpstring( "Mit document_dir absolut gemachter Dateiname" )]
        HRESULT Document_filename( [out,retval] BSTR* filename );

        [propget,helpstring( "Nach einem Fehler fortfahren?" )]
        HRESULT On_error_continue( [out,retval] VARIANT_BOOL* cont );

        [propput,helpstring( "Nach einem Fehler fortfahren?" )]
        HRESULT On_error_continue( [in] VARIANT_BOOL cont );

        [propput,helpstring( "Funktionsobjekt, das ein Aufbereitungsobjekt (processing object) erzeugt." )]
        HRESULT Processing_object_constructor( [in] IDispatch* constructor_function );

        [propget,helpstring( "Kontext, der dem Aufbereitungsobjekt übergeben wird" )]
        HRESULT Context( [out,retval] VARIANT* context );

        [propput,helpstring( "Kontext, der dem Aufbereitungsobjekt übergeben wird" )]
        HRESULT Context( [in] VARIANT context );

        [propput,helpstring( "Funktionsobjekt, das ein Objekt erzeugt, dessen Methode document_written() gerufen wird." )]
        HRESULT Output_object_constructor( [in] IDispatch* constructor_function );

        [propput,helpstring( "Name der Wiederanlaufdatei, die die Zahl der erfolgreich verarbeiteten Aufträge enthält" )]
        HRESULT Rerun_filename( [in] BSTR filename );

        [propget,helpstring( "Name der Wiederanlaufdatei, die die Zahl der erfolgreich verarbeiteten Aufträge enthält" )]
        HRESULT Rerun_filename( [out,retval] BSTR* filename );

        [propput,helpstring("Mehrere Aufbereitungen sollen zu einem Dokumente zusammengefasst werden")]
        HRESULT Collect( [in] int count );

        [propget,helpstring("Mehrere Aufbereitungen sollen zu einem Dokumente zusammengefasst werden")]
        HRESULT Collect( [out,retval] int* count );

        [helpstring( "Die Methode sollte vor dem ersten process() gerufen werden." )]
        HRESULT Open();

        [helpstring( "Die Methode sollte zum Schluss gerufen werden, damit nicht ein Fehler beim Abschluss der Ausgabedatei verloren geht" )]
        HRESULT Close();

        [helpstring( "Einen Schritt ausführen (Methode für Spooler)" )]
        HRESULT Process( [out,retval] VARIANT_BOOL* Ok );

        [helpstring( "Alle Aufträge ausführen" )]
        HRESULT Process_all();

        [propget]
        HRESULT Processor( [out,retval] Ifactory_processor** processor );

        [propget]
        HRESULT Record_nr( [out,retval] int* record_nr );

        [propget,helpstring( "Wiederanlaufdatei wird abgearbeitet" )]
        HRESULT Rerunning( [out,retval] VARIANT_BOOL* rerunning);

        HRESULT Eof( [out,retval] VARIANT_BOOL* eof );
    }

    [
        uuid       ( 9F716A46-D1F0-11CF-869D-444553540000 ),
        helpstring ( "Serienaufbereitung" )
    ]
    coclass Series_factory
    {
        [default] interface Iseries_factory;
    }

    //-----------------------------------------------------------------------------------Ausgabeformat

    //typedef 
    enum Ausgabeformat                 // Ausgabeformat
    {
        format_std,
        format_waehrung         // 0.009,99
    };

    //-------------------------------------------------------------------------------Embed_flags 

    //typedef 
    enum Embed_flags                // Mit Flags in rtf.h abgleichen!
    {
        embed_char_prop          = 0x01,    // Eigenschaft eines Zeiches    (flag_char_prop)
        embed_para_prop          = 0x02,    // Eigenschaft eines Absatzes   (flag_para_prop)
        embed_sect_prop          = 0x04,    // Eigenschaft eines Abschnitts (flag_sect_prop)
        embed_doc_prop           = 0x08,    // Eigenschaft des Dokuments    (flag_doc_prop)
    };

    //------------------------------------------------------------------Factory_text_constructor
    
    [
        uuid(6EB42D31-1BAD-11d1-9A05-0060973692FD),
        helpstring ( "Das von der Factory generierte Skript generiert hiermit das Ergebnis als einfachen Text" ),
        odl,
        dual,
        nonextensible
    ]
    interface Ifactory_text_constructor : IDispatch
    {
        HRESULT Put                     ( [in] VARIANT* text, VARIANT_BOOL raw );
        HRESULT Put_formatted           ( [in] VARIANT* text, [in] enum Ausgabeformat format, [in] BSTR source_expression );
        HRESULT Embed                   ( [in] BSTR filename );
        HRESULT Rtf_start               ();
        HRESULT Rtf_finish              ();
    }

    [
        uuid(6EB42D32-A6BF-11D0-8381-00A0C91EF7B9),
        helpstring("Factory_global_object Class")
    ]
    coclass Factory_text_constructor
    {
        [default] interface Ifactory_text_constructor;
    }

    //-------------------------------------------------------------------Factory_rtf_constructor
    
    [
        uuid(6EB42D33-1BAD-11d1-9A05-0060973692FD),
        helpstring ( "Das von der Factory generierte Skript generiert hiermit das Ergebnis als RTF" ),
        odl,
        dual,
        nonextensible
    ]
    interface Ifactory_rtf_constructor : IDispatch
    {
        HRESULT Put                     ( [in] VARIANT* text, VARIANT_BOOL raw );
        HRESULT Put_formatted           ( [in] VARIANT* text, [in] enum Ausgabeformat format, [in] BSTR source_expression );
        HRESULT Embed                   ( [in] BSTR filename, [in,defaultvalue(0)] enum Embed_flags embed_flags );
        HRESULT Rtf_start               ();
        HRESULT Rtf_finish              ();

        HRESULT Rtf_prop                ( [in] int code, [in] int Value );
        HRESULT Rtf_put                 ( [in] int begin_ptr, [in] int end_ptr );
        HRESULT Rtf_open                ( [in] int entity_ptr );
        HRESULT Rtf_close               ();
        HRESULT Rtf_include_begin       ();
        HRESULT Rtf_include_end         ();

        [propput]
        HRESULT Suppress_subdocument    ( [in,defaultvalue(-1)] VARIANT_BOOL Suppressed );

        [propget]
        HRESULT Suppress_subdocument    ( [out,retval] VARIANT_BOOL* Result );
    }

    [
        uuid(6EB42D34-A6BF-11D0-8381-00A0C91EF7B9),
        helpstring("Factory_rtf_constructor Class")
    ]
    coclass Factory_rtf_constructor
    {
        [default] interface Ifactory_rtf_constructor;
    }

    //-----------------------------------------------------------------------------Word_application
    
    [
        uuid(6EB42D35-1BAD-11d1-9A05-0060973692FD),
        odl,
        dual,
        nonextensible
    ]
    interface Iword_application : IDispatch
    {
        [helpstring("Beendet alle Prozesse von winword.exe")]
        HRESULT Kill_all_words          ( [in,defaultvalue("")] BSTR empty, [out,retval] int* count );

        HRESULT Load                    ();

        [propget]
        HRESULT App                     ( [out,retval] IDispatch** word_application_interface );

        HRESULT Print                   ( [in] BSTR filename, [in] BSTR parameters );

      //HRESULT Convert_to_doc          ( [in] BSTR source_filename, [in] BSTR destination_filename, [in,defaultvalue("")] BSTR doc_type );
    }

    [
        uuid(6EB42D36-A6BF-11D0-8381-00A0C91EF7B9),
    ]
    coclass Word_application
    {
        [default] interface Iword_application;
    }

    //----------------------------------------------------------------------------------Ghostscript
    
    [
        uuid(6EB42D37-1BAD-11d1-9A05-0060973692FD),
        odl,
        dual,
        nonextensible
    ]
    interface Ighostscript : IDispatch
    {
        [id(0)]
        HRESULT Run                     ( [in] BSTR parameters );

        [propget]
        HRESULT Collect_stdout          ( [out,retval] VARIANT_BOOL* collect );

        [propput]
        HRESULT Collect_stdout          ( [in] VARIANT_BOOL collect );

        [propget]
        HRESULT Stdout                  ( [out,retval] BSTR* stdout_text );

        [helpstring("Optionaler Aufruf zum Laden der DLL und zur Initialisierung von GhostScript")]
        HRESULT Init                    ();

        [helpstring("Schließt Ghostscript. Das Objekt kann anschließend wiederverwendet werden")]
        HRESULT Close                   ();
    }

    [
        uuid(6EB42D38-A6BF-11D0-8381-00A0C91EF7B9),
    ]
    coclass Ghostscript
    {
        [default] interface Ighostscript;
    }

    //----------------------------------------------------------------------------------------Rerun
    
    [
        uuid(5C2BFBBD-E82F-459c-95BB-CE3E3BCBE6B3),
        odl,
        dual,
        nonextensible
    ]
    interface Irerun : IDispatch
    {
        HRESULT Open                        ( [in] BSTR Filename );
        
        HRESULT Close                       ();

        HRESULT Process_next_record         ( [out,retval] VARIANT_BOOL* process_next_record );

      //HRESULT Processing_was_ok           ( [in] VARIANT_BOOL Ok );

      //HRESULT Commit                      ();

        HRESULT Set_record_ok               ( int Record_number, VARIANT_BOOL ok );

        [propget]
        HRESULT Rerunning                   ( [out,retval] VARIANT_BOOL* result );

        [propget,helpstring("process_next_record() zählt record_number hoch")]
        HRESULT Record_number               ( [out,retval] int* result );

        [propget]
        HRESULT Ok                          ( [out,retval] VARIANT_BOOL* result );
    }

    [
        uuid(82AD717A-A075-400b-8673-B6578FCBD835),
    ]
    coclass Rerun
    {
        [default] interface Irerun;
    }
};

